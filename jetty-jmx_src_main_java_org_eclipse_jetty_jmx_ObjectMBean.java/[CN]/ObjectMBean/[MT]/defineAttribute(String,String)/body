{
  String description="";
  boolean writable=true;
  boolean onMBean=false;
  boolean convert=false;
  if (metaData != null) {
    String[] tokens=metaData.split(":",3);
    for (int t=0; t < tokens.length - 1; t++) {
      tokens[t]=tokens[t].trim();
      if ("RO".equals(tokens[t]))       writable=false;
 else {
        onMBean=("MMBean".equalsIgnoreCase(tokens[t]) || "MBean".equalsIgnoreCase(tokens[t]));
        convert=("MMBean".equalsIgnoreCase(tokens[t]) || "MObject".equalsIgnoreCase(tokens[t]));
      }
    }
    description=tokens[tokens.length - 1];
  }
  String uName=name.substring(0,1).toUpperCase() + name.substring(1);
  Class oClass=onMBean ? this.getClass() : _managed.getClass();
  if (Log.isDebugEnabled())   Log.debug("defineAttribute " + name + " "+ onMBean+ ":"+ writable+ ":"+ oClass+ ":"+ description);
  Class type=null;
  Method getter=null;
  Method setter=null;
  Method[] methods=oClass.getMethods();
  for (int m=0; m < methods.length; m++) {
    if ((methods[m].getModifiers() & Modifier.PUBLIC) == 0)     continue;
    if (methods[m].getName().equals("get" + uName) && methods[m].getParameterTypes().length == 0) {
      if (getter != null) {
        Log.warn("Multiple mbean getters for attr " + name + " in "+ oClass);
        continue;
      }
      getter=methods[m];
      if (type != null && !type.equals(methods[m].getReturnType())) {
        Log.warn("Type conflict for mbean attr " + name + " in "+ oClass);
        continue;
      }
      type=methods[m].getReturnType();
    }
    if (methods[m].getName().equals("is" + uName) && methods[m].getParameterTypes().length == 0) {
      if (getter != null) {
        Log.warn("Multiple mbean getters for attr " + name + " in "+ oClass);
        continue;
      }
      getter=methods[m];
      if (type != null && !type.equals(methods[m].getReturnType())) {
        Log.warn("Type conflict for mbean attr " + name + " in "+ oClass);
        continue;
      }
      type=methods[m].getReturnType();
    }
    if (writable && methods[m].getName().equals("set" + uName) && methods[m].getParameterTypes().length == 1) {
      if (setter != null) {
        Log.warn("Multiple setters for mbean attr " + name + " in "+ oClass);
        continue;
      }
      setter=methods[m];
      if (type != null && !type.equals(methods[m].getParameterTypes()[0])) {
        Log.warn("Type conflict for mbean attr " + name + " in "+ oClass);
        continue;
      }
      type=methods[m].getParameterTypes()[0];
    }
  }
  if (convert) {
    if (type == null) {
      Log.warn("No mbean type for " + name + " on "+ _managed.getClass());
      return null;
    }
    if (type.isPrimitive() && !type.isArray()) {
      Log.warn("Cannot convert mbean primative " + name);
      return null;
    }
  }
  if (getter == null && setter == null) {
    Log.warn("No mbean getter or setters found for " + name + " in "+ oClass);
    return null;
  }
  try {
    _getters.put(name,getter);
    _setters.put(name,setter);
    MBeanAttributeInfo info=null;
    if (convert) {
      _convert.add(name);
      if (type.isArray())       info=new MBeanAttributeInfo(name,OBJECT_NAME_ARRAY_CLASS,description,getter != null,setter != null,getter != null && getter.getName().startsWith("is"));
 else       info=new MBeanAttributeInfo(name,OBJECT_NAME_CLASS,description,getter != null,setter != null,getter != null && getter.getName().startsWith("is"));
    }
 else     info=new MBeanAttributeInfo(name,description,getter,setter);
    return info;
  }
 catch (  Exception e) {
    Log.warn(name + ": " + metaData,e);
    throw new IllegalArgumentException(e.toString());
  }
}
