{
  List<DecoderMetadata> metadatas=new ArrayList<>();
  if (Decoder.Binary.class.isAssignableFrom(decoder)) {
    Class<?> objType=getDecoderMessageClass(decoder,Decoder.Binary.class);
    metadatas.add(new DecoderMetadata(objType,decoder,MessageType.BINARY,false));
  }
  if (Decoder.BinaryStream.class.isAssignableFrom(decoder)) {
    Class<?> objType=getDecoderMessageClass(decoder,Decoder.BinaryStream.class);
    metadatas.add(new DecoderMetadata(objType,decoder,MessageType.BINARY,true));
  }
  if (Decoder.Text.class.isAssignableFrom(decoder)) {
    Class<?> objType=getDecoderMessageClass(decoder,Decoder.Text.class);
    metadatas.add(new DecoderMetadata(objType,decoder,MessageType.TEXT,false));
  }
  if (Decoder.TextStream.class.isAssignableFrom(decoder)) {
    Class<?> objType=getDecoderMessageClass(decoder,Decoder.TextStream.class);
    metadatas.add(new DecoderMetadata(objType,decoder,MessageType.TEXT,true));
  }
  if (!ReflectUtils.isDefaultConstructable(decoder)) {
    throw new InvalidSignatureException("Decoder must have public, no-args constructor: " + decoder.getName());
  }
  if (metadatas.size() <= 0) {
    throw new InvalidSignatureException("Not a valid Decoder class: " + decoder.getName());
  }
  return trackMetadata(decoder,metadatas);
}
