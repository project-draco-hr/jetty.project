{
  long nanos=unit.toNanos(time);
  E e=null;
  final Lock headLock=_headLock;
  headLock.lockInterruptibly();
  try {
    try {
      while (_size.get() == 0) {
        if (nanos <= 0)         return null;
        nanos=_notEmpty.awaitNanos(nanos);
      }
    }
 catch (    InterruptedException x) {
      _notEmpty.signal();
      throw x;
    }
    int head=_head;
    e=(E)_elements[head];
    _elements[head]=null;
    _head=(head + 1) % _capacity;
    if (_size.decrementAndGet() > 0)     _notEmpty.signal();
  }
  finally {
    headLock.unlock();
  }
  return e;
}
