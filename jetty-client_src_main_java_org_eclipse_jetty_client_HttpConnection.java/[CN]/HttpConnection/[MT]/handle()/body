{
  try {
    int no_progress=0;
    boolean failed=false;
    while (_endp.isBufferingInput() || _endp.isOpen()) {
synchronized (this) {
        while (_exchange == null) {
          if (_endp.isBlocking()) {
            try {
              this.wait();
            }
 catch (            InterruptedException e) {
              throw new InterruptedIOException();
            }
          }
 else {
            long filled=_parser.fill();
            if (filled < 0) {
              close();
            }
 else {
              _parser.skipCRLF();
              if (_parser.isMoreInBuffer()) {
                LOG.warn("Unexpected data received but no request sent");
                close();
              }
            }
            return this;
          }
        }
      }
      try {
        if (_exchange.getStatus() == HttpExchange.STATUS_WAITING_FOR_COMMIT) {
          no_progress=0;
          commitRequest();
        }
        long io=0;
        _endp.flush();
        if (_generator.isComplete()) {
          if (!_requestComplete) {
            _requestComplete=true;
            _exchange.getEventListener().onRequestComplete();
          }
        }
 else {
synchronized (this) {
            if (_exchange == null)             continue;
          }
          long flushed=_generator.flushBuffer();
          io+=flushed;
          if (!_generator.isComplete()) {
            if (_exchange != null) {
              InputStream in=_exchange.getRequestContentSource();
              if (in != null) {
                if (_requestContentChunk == null || _requestContentChunk.length() == 0) {
                  _requestContentChunk=_exchange.getRequestContentChunk();
                  if (_requestContentChunk != null)                   _generator.addContent(_requestContentChunk,false);
 else                   _generator.complete();
                  flushed=_generator.flushBuffer();
                  io+=flushed;
                }
              }
 else               _generator.complete();
            }
 else             _generator.complete();
          }
        }
        if (_generator.isComplete() && !_requestComplete) {
          _requestComplete=true;
          _exchange.getEventListener().onRequestComplete();
        }
        if (!_parser.isComplete() && (_generator.isComplete() || _generator.isCommitted() && !_endp.isBlocking())) {
          long filled=_parser.parseAvailable();
          io+=filled;
        }
        if (io > 0)         no_progress=0;
 else         if (no_progress++ >= 1 && !_endp.isBlocking()) {
          if (_endp instanceof SslSelectChannelEndPoint && !_generator.isComplete() && !_generator.isEmpty()) {
            long flushed=_generator.flushBuffer();
            if (flushed > 0)             continue;
          }
          return this;
        }
      }
 catch (      Throwable e) {
        LOG.debug("Failure on " + _exchange,e);
        if (e instanceof ThreadDeath)         throw (ThreadDeath)e;
        failed=true;
synchronized (this) {
          if (_exchange != null) {
            if (_exchange.getStatus() != HttpExchange.STATUS_CANCELLING && _exchange.getStatus() != HttpExchange.STATUS_CANCELLED) {
              _exchange.setStatus(HttpExchange.STATUS_EXCEPTED);
              _exchange.getEventListener().onException(e);
            }
          }
 else {
            if (e instanceof IOException)             throw (IOException)e;
            if (e instanceof Error)             throw (Error)e;
            if (e instanceof RuntimeException)             throw (RuntimeException)e;
            throw new RuntimeException(e);
          }
        }
      }
 finally {
        boolean complete=false;
        boolean close=failed;
        if (!failed) {
          if (_generator.isComplete()) {
            if (!_requestComplete) {
              _requestComplete=true;
              _exchange.getEventListener().onRequestComplete();
            }
            if (_parser.isComplete()) {
              _exchange.cancelTimeout(_destination.getHttpClient());
              complete=true;
            }
          }
          if (!_endp.isOpen() && !(_parser.isComplete() || _parser.isIdle())) {
            complete=true;
            _parser.parseAvailable();
            if (!(_parser.isComplete() || _parser.isIdle())) {
              LOG.warn("Incomplete {} {}",_parser,_endp);
              if (_exchange != null && !_exchange.isDone()) {
                _exchange.setStatus(HttpExchange.STATUS_EXCEPTED);
                _exchange.getEventListener().onException(new EOFException("Incomplete"));
              }
            }
          }
        }
        if (_endp.isInputShutdown() && !_parser.isComplete()) {
          if (_exchange != null && !_exchange.isDone()) {
            _exchange.setStatus(HttpExchange.STATUS_EXCEPTED);
            _exchange.getEventListener().onException(new EOFException("Incomplete"));
          }
          _endp.close();
        }
        if (complete || failed) {
synchronized (this) {
            if (!close)             close=shouldClose();
            reset(true);
            no_progress=0;
            if (_exchange != null) {
              HttpExchange exchange=_exchange;
              _exchange=null;
              if (!close)               _endp.setMaxIdleTime((int)_destination.getHttpClient().getIdleTimeout());
              if (_status == HttpStatus.SWITCHING_PROTOCOLS_101) {
                Connection switched=exchange.onSwitchProtocol(_endp);
                if (switched != null) {
                  exchange=_pipeline;
                  _pipeline=null;
                  if (exchange != null)                   _destination.send(exchange);
                  return switched;
                }
              }
              if (_pipeline == null) {
                if (!isReserved())                 _destination.returnConnection(this,close);
              }
 else {
                if (close) {
                  if (!isReserved())                   _destination.returnConnection(this,close);
                  exchange=_pipeline;
                  _pipeline=null;
                  _destination.send(exchange);
                }
 else {
                  exchange=_pipeline;
                  _pipeline=null;
                  send(exchange);
                }
              }
            }
          }
        }
      }
    }
  }
  finally {
    _parser.returnBuffers();
    if (!_generator.isComplete() && _generator.getBytesBuffered() > 0 && _endp.isOpen() && _endp instanceof AsyncEndPoint) {
      ((AsyncEndPoint)_endp).scheduleWrite();
    }
  }
  return this;
}
