{
  if (_exchange != null)   _exchange.associate(this);
  try {
    int no_progress=0;
    boolean failed=false;
    while (_endp.isBufferingInput() || _endp.isOpen()) {
synchronized (this) {
        while (_exchange == null) {
          if (_endp.isBlocking()) {
            try {
              this.wait();
            }
 catch (            InterruptedException e) {
              throw new InterruptedIOException();
            }
          }
 else {
            _parser.fill();
            _parser.skipCRLF();
            if (_parser.isMoreInBuffer()) {
              Log.warn("Unexpected data received but no request sent");
              close();
            }
            return this;
          }
        }
        if (!_exchange.isAssociated())         _exchange.associate(this);
      }
      try {
        if (_exchange.getStatus() == HttpExchange.STATUS_WAITING_FOR_COMMIT) {
          no_progress=0;
          commitRequest();
        }
        long io=0;
        _endp.flush();
        if (_generator.isComplete()) {
          if (!_requestComplete) {
            _requestComplete=true;
            _exchange.getEventListener().onRequestComplete();
          }
        }
 else {
synchronized (this) {
            if (_exchange == null)             continue;
          }
          long flushed=_generator.flushBuffer();
          io+=flushed;
          if (!_generator.isComplete()) {
            if (_exchange != null) {
              InputStream in=_exchange.getRequestContentSource();
              if (in != null) {
                if (_requestContentChunk == null || _requestContentChunk.length() == 0) {
                  _requestContentChunk=_exchange.getRequestContentChunk();
                  _destination.getHttpClient().schedule(_timeout);
                  if (_requestContentChunk != null)                   _generator.addContent(_requestContentChunk,false);
 else                   _generator.complete();
                  flushed=_generator.flushBuffer();
                  io+=flushed;
                }
              }
 else               _generator.complete();
            }
 else             _generator.complete();
          }
        }
        if (_generator.isComplete() && !_requestComplete) {
          _requestComplete=true;
          _exchange.getEventListener().onRequestComplete();
        }
        if (!_parser.isComplete() && (_generator.isComplete() || _generator.isCommitted() && !_endp.isBlocking())) {
          long filled=_parser.parseAvailable();
          io+=filled;
        }
        if (io > 0)         no_progress=0;
 else         if (no_progress++ >= 1 && !_endp.isBlocking()) {
          if (_endp instanceof SslSelectChannelEndPoint && !_generator.isComplete() && !_generator.isEmpty()) {
            long flushed=_generator.flushBuffer();
            if (flushed > 0)             continue;
          }
          return this;
        }
      }
 catch (      Throwable e) {
        Log.debug("Failure on " + _exchange,e);
        if (e instanceof ThreadDeath)         throw (ThreadDeath)e;
        failed=true;
synchronized (this) {
          if (_exchange != null) {
            if (_exchange.getStatus() != HttpExchange.STATUS_CANCELLING) {
              _exchange.setStatus(HttpExchange.STATUS_EXCEPTED);
              _exchange.getEventListener().onException(e);
            }
          }
 else {
            if (e instanceof IOException)             throw (IOException)e;
            if (e instanceof Error)             throw (Error)e;
            if (e instanceof RuntimeException)             throw (RuntimeException)e;
            throw new RuntimeException(e);
          }
        }
      }
 finally {
        boolean complete=false;
        boolean close=failed;
        if (!failed) {
          if (_generator.isComplete()) {
            if (!_requestComplete) {
              _requestComplete=true;
              _exchange.getEventListener().onRequestComplete();
            }
            if (_parser.isComplete()) {
              _destination.getHttpClient().cancel(_timeout);
              complete=true;
            }
          }
        }
        if (_generator.isComplete() && !_parser.isComplete()) {
          if (!_endp.isOpen() || _endp.isInputShutdown()) {
            complete=true;
            close=true;
            close();
          }
        }
        if (complete || failed) {
synchronized (this) {
            if (!close)             close=shouldClose();
            reset(true);
            no_progress=0;
            if (_exchange != null) {
              HttpExchange exchange=_exchange;
              _exchange.disassociate();
              if (_exchange.getTimeout() > 0 && _exchange.getTimeout() != getDestination().getHttpClient().getTimeout())               _endp.setMaxIdleTime((int)getDestination().getHttpClient().getTimeout());
              _exchange=null;
              if (_status == HttpStatus.SWITCHING_PROTOCOLS_101) {
                Connection switched=exchange.onSwitchProtocol(_endp);
                if (switched != null) {
                  exchange=_pipeline;
                  _pipeline=null;
                  if (exchange != null)                   _destination.send(exchange);
                  return switched;
                }
              }
              if (_pipeline == null) {
                if (!isReserved())                 _destination.returnConnection(this,close);
              }
 else {
                if (close) {
                  if (!isReserved())                   _destination.returnConnection(this,close);
                  exchange=_pipeline;
                  _pipeline=null;
                  _destination.send(exchange);
                }
 else {
                  exchange=_pipeline;
                  _pipeline=null;
                  send(exchange);
                }
              }
            }
          }
        }
      }
    }
  }
  finally {
    if (_exchange != null && _exchange.isAssociated()) {
      _exchange.disassociate();
    }
    if (!_generator.isComplete() && _generator.getBytesBuffered() > 0 && _endp instanceof AsyncEndPoint) {
      ((AsyncEndPoint)_endp).setWritable(false);
    }
  }
  return this;
}
