{
  if (_buffer == null)   _buffer=_buffers.getBuffer();
  int total_filled=0;
  while (true) {
    int available=_buffer.length();
    if (available < _state.getMinSize() || _state == State.DATA && available < _count) {
      _buffer.compact();
      if (_buffer.space() == 0)       throw new IllegalStateException("FULL");
      try {
        int filled=_endp.isOpen() ? _endp.fill(_buffer) : -1;
        if (filled <= 0)         return total_filled > 0 ? total_filled : -1;
        total_filled+=filled;
        available=_buffer.length();
      }
 catch (      IOException e) {
        Log.debug(e);
        return total_filled > 0 ? total_filled : -1;
      }
    }
    byte b;
    while (_state != State.DATA && available-- > 0) {
switch (_state) {
case START:
        b=_buffer.get();
      _opcode=(byte)(b & 0xf);
    _flags=(byte)(b >> 4);
  _state=State.LENGTH_7;
continue;
case LENGTH_7:
b=_buffer.get();
switch (b) {
case 127:
_length=0;
_count=8;
_state=State.LENGTH_63;
break;
case 126:
_length=0;
_count=2;
_state=State.LENGTH_16;
break;
default :
_length=(0x7f & b);
_count=(int)_length;
_state=State.DATA;
}
continue;
case LENGTH_16:
b=_buffer.get();
_length=_length << 8 | b;
if (--_count == 0) {
if (_length >= _buffer.capacity() - 4) throw new IllegalStateException("TOO LARGE");
_count=(int)_length;
_state=State.DATA;
}
continue;
case LENGTH_63:
b=_buffer.get();
_length=_length << 8 | b;
if (--_count == 0) {
if (_length >= _buffer.capacity() - 10) throw new IllegalStateException("TOO LARGE");
_count=(int)_length;
_state=State.DATA;
}
continue;
}
}
if (_state == State.DATA && available >= _count) {
_handler.onFrame(_flags,_opcode,_buffer.get(_count));
_count=0;
_state=State.START;
if (_buffer.length() == 0) {
_buffers.returnBuffer(_buffer);
_buffer=null;
}
return total_filled;
}
}
}
