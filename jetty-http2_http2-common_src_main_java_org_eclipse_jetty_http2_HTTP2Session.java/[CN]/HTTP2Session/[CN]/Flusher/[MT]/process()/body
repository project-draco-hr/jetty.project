{
synchronized (queue) {
    if (closed)     return Action.IDLE;
    int sessionWindow=getWindowSize();
    int nonStalledIndex=0;
    int size=queue.size();
    while (nonStalledIndex < size) {
      FlusherEntry entry=queue.get(nonStalledIndex);
      IStream stream=entry.stream;
      int frameWindow=entry.frame.getFlowControlledLength();
      if (frameWindow > 0) {
        if (sessionWindow <= 0) {
          flowControl.onSessionStalled(HTTP2Session.this);
          ++nonStalledIndex;
          continue;
        }
        if (stream != null) {
          Integer streamWindow=streams.get(stream);
          if (streamWindow == null) {
            streamWindow=stream.getWindowSize();
            streams.put(stream,streamWindow);
          }
          if (streamWindow <= 0) {
            flowControl.onStreamStalled(stream);
            ++nonStalledIndex;
            continue;
          }
        }
      }
      queue.remove(nonStalledIndex);
      --size;
      if (stream != null && stream.isReset() && frameWindow > 0) {
        reset.add(entry);
        continue;
      }
      sessionWindow-=frameWindow;
      if (stream != null && frameWindow > 0)       streams.put(stream,streams.get(stream) - frameWindow);
      active.add(entry);
      if (active.size() == maxGather)       break;
    }
    streams.clear();
  }
  for (int i=0; i < reset.size(); ++i) {
    FlusherEntry entry=reset.get(i);
    entry.failed(new IllegalStateException());
  }
  reset.clear();
  if (active.isEmpty())   return Action.IDLE;
  for (int i=0; i < active.size(); ++i) {
    FlusherEntry entry=active.get(i);
    entry.generate(lease);
  }
  List<ByteBuffer> byteBuffers=lease.getByteBuffers();
  endPoint.write(this,byteBuffers.toArray(new ByteBuffer[byteBuffers.size()]));
  return Action.SCHEDULED;
}
