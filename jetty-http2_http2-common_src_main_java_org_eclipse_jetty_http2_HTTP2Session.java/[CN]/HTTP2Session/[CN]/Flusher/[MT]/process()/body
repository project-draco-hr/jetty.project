{
synchronized (queue) {
    if (closed)     return Action.IDLE;
    int sessionWindow=getWindowSize();
    int nonStalledIndex=0;
    int size=queue.size();
    while (nonStalledIndex < size) {
      FlusherEntry entry=queue.get(nonStalledIndex);
      IStream stream=entry.stream;
      int remaining=0;
      if (entry.frame instanceof DataFrame) {
        DataFrame dataFrame=(DataFrame)entry.frame;
        remaining=dataFrame.remaining();
        if (remaining > 0) {
          if (sessionWindow <= 0) {
            flowControl.onSessionStalled(HTTP2Session.this);
            ++nonStalledIndex;
            continue;
          }
          if (stream != null) {
            Integer streamWindow=streams.get(stream);
            if (streamWindow == null) {
              streamWindow=stream.getWindowSize();
              streams.put(stream,streamWindow);
            }
            if (streamWindow <= 0) {
              flowControl.onStreamStalled(stream);
              ++nonStalledIndex;
              continue;
            }
          }
        }
      }
      queue.remove(nonStalledIndex);
      --size;
      if (stream != null && stream.isReset() && remaining > 0) {
        reset.add(entry);
        continue;
      }
      sessionWindow-=remaining;
      if (stream != null && remaining > 0)       streams.put(stream,streams.get(stream) - remaining);
      active.add(entry);
      if (active.size() == maxGather)       break;
    }
    streams.clear();
  }
  for (int i=0; i < reset.size(); ++i) {
    FlusherEntry entry=reset.get(i);
    entry.failed(new IllegalStateException());
  }
  reset.clear();
  if (active.isEmpty())   return Action.IDLE;
  for (int i=0; i < active.size(); ++i) {
    FlusherEntry entry=active.get(i);
    entry.generate(lease);
  }
  List<ByteBuffer> byteBuffers=lease.getByteBuffers();
  endPoint.write(this,byteBuffers.toArray(new ByteBuffer[byteBuffers.size()]));
  return Action.SCHEDULED;
}
