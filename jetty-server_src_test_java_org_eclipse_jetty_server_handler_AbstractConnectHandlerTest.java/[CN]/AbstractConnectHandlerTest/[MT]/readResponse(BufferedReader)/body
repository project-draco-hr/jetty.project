{
  String line=reader.readLine();
  if (line == null)   throw new EOFException();
  Matcher responseLine=Pattern.compile("HTTP/1\\.1\\s+(\\d+)").matcher(line);
  assertTrue(responseLine.lookingAt());
  String code=responseLine.group(1);
  Map<String,String> headers=new LinkedHashMap<String,String>();
  while ((line=reader.readLine()) != null) {
    if (line.trim().length() == 0)     break;
    Matcher header=Pattern.compile("([^:]+):\\s*(.*)").matcher(line);
    assertTrue(header.lookingAt());
    String headerName=header.group(1);
    String headerValue=header.group(2);
    headers.put(headerName.toLowerCase(),headerValue.toLowerCase());
  }
  StringBuilder body;
  if (headers.containsKey("content-length")) {
    int readLen=0;
    int length=Integer.parseInt(headers.get("content-length"));
    body=new StringBuilder(length);
    try {
      for (int i=0; i < length; ++i) {
        char c=(char)reader.read();
        body.append(c);
        readLen++;
      }
    }
 catch (    SocketTimeoutException e) {
      System.err.printf("Read %,d bytes (out of an expected %,d bytes)%n",readLen,length);
      throw e;
    }
  }
 else   if ("chunked".equals(headers.get("transfer-encoding"))) {
    body=new StringBuilder(64 * 1024);
    while ((line=reader.readLine()) != null) {
      if ("0".equals(line)) {
        line=reader.readLine();
        assertEquals("",line);
        break;
      }
      try {
        Thread.sleep(5);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
      int length=Integer.parseInt(line,16);
      for (int i=0; i < length; ++i) {
        char c=(char)reader.read();
        body.append(c);
      }
      line=reader.readLine();
      assertEquals("",line);
    }
  }
 else   throw new IllegalStateException();
  return new Response(code,headers,body.toString().trim());
}
