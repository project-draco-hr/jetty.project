{
  long delay=1000;
  start(new HttpServlet(){
    @Override protected void service(    HttpServletRequest request,    HttpServletResponse response) throws ServletException, IOException {
      ServletInputStream input=request.getInputStream();
      byte[] buffer=new byte[8192];
      while (true) {
        int read=input.read(buffer);
        Log.getLogger(IdleTimeoutTest.class).info("Read {} bytes",read);
        if (read < 0)         break;
        sleep(delay);
      }
    }
  }
);
  connector.setIdleTimeout(2 * delay);
  Session session=newClient(new Session.Listener.Adapter());
  MetaData.Request metaData=newRequest("POST",new HttpFields());
  HeadersFrame requestFrame=new HeadersFrame(metaData,null,false);
  FuturePromise<Stream> promise=new FuturePromise<>();
  CountDownLatch latch=new CountDownLatch(1);
  session.newStream(requestFrame,promise,new Stream.Listener.Adapter(){
    @Override public void onHeaders(    Stream stream,    HeadersFrame frame){
      if (frame.isEndStream())       latch.countDown();
    }
  }
);
  Stream stream=promise.get(5,TimeUnit.SECONDS);
  ByteBuffer data=ByteBuffer.allocate(FlowControlStrategy.DEFAULT_WINDOW_SIZE + 1);
  stream.data(new DataFrame(stream.getId(),data,true),Callback.NOOP);
  Assert.assertTrue(latch.await(5,TimeUnit.SECONDS));
}
