{
  String response="";
  _connection=connection;
  _te=te;
  gen.setVersion(HttpVersion.fromVersion(version));
  gen.setResponse(_code,reason);
  gen.setHead(_head);
  if (_contentType != null)   fields.put("Content-Type",_contentType);
  if (_contentLength != null) {
    fields.put("Content-Length",_contentLength);
    gen.setContentLength(Long.parseLong(_contentLength));
  }
  if (_connection != null)   fields.put("Connection",_connection);
  if (_te != null)   fields.put("Transfer-Encoding",_te);
  if (_other != null)   fields.put("Other",_other);
  ByteBuffer content=_body == null ? null : BufferUtil.toBuffer(_body);
  if (content != null)   content.limit(0);
  ByteBuffer chunk=null;
  ByteBuffer buffer=null;
  mainLoop:   while (true) {
    if (content != null && content.position() < content.capacity()) {
      if (content.remaining() == 0) {
        if (chunks-- > 1)         content.limit(content.position() + content.remaining() / 2);
 else         content.limit(content.capacity());
      }
switch (gen.getState()) {
case START:
case COMPLETING_UNCOMMITTED:
case COMMITTED:
case COMPLETING:
case END:
      }
    }
switch (gen.prepareContent(chunk,buffer,content)) {
case FLUSH:
      if (BufferUtil.hasContent(chunk)) {
        response+=BufferUtil.toString(chunk);
        chunk.position(chunk.limit());
      }
    if (BufferUtil.hasContent(buffer)) {
      response+=BufferUtil.toString(buffer);
      buffer.position(buffer.limit());
    }
  break;
case FLUSH_CONTENT:
if (BufferUtil.hasContent(chunk)) {
  response+=BufferUtil.toString(chunk);
  chunk.position(chunk.limit());
}
if (BufferUtil.hasContent(content)) {
response+=BufferUtil.toString(content);
content.position(content.limit());
}
break;
case NEED_BUFFER:
buffer=BufferUtil.allocate(8192);
break;
case NEED_CHUNK:
chunk=BufferUtil.allocate(HttpGenerator.CHUNK_SIZE);
break;
case NEED_COMMIT:
{
commitLoop: while (true) {
ByteBuffer header=BufferUtil.allocate(4096);
switch (gen.commit(fields,header,buffer,content,chunks == 0)) {
case FLUSH:
if (BufferUtil.hasContent(header)) {
response+=BufferUtil.toString(header);
header.position(header.limit());
}
if (BufferUtil.hasContent(buffer)) {
response+=BufferUtil.toString(buffer);
buffer.position(buffer.limit());
}
break;
case FLUSH_CONTENT:
if (BufferUtil.hasContent(header)) {
response+=BufferUtil.toString(header);
header.position(header.limit());
}
if (BufferUtil.hasContent(content)) {
response+=BufferUtil.toString(content);
content.position(content.limit());
}
break;
case NEED_BUFFER:
buffer=BufferUtil.allocate(8192);
break;
case OK:
break commitLoop;
default :
throw new IllegalStateException(gen.toString());
}
}
}
break;
case NEED_COMPLETE:
{
completeLoop: while (true) {
ByteBuffer header=BufferUtil.allocate(4096);
switch (gen.complete(chunk,buffer)) {
case FLUSH:
if (BufferUtil.hasContent(chunk)) {
response+=BufferUtil.toString(chunk);
chunk.position(chunk.limit());
}
if (BufferUtil.hasContent(buffer)) {
response+=BufferUtil.toString(buffer);
buffer.position(buffer.limit());
}
break;
case OK:
break completeLoop;
default :
throw new IllegalStateException(gen.toString());
}
}
}
break;
}
continue;
}
while (true) {
switch (gen.complete(chunk,buffer)) {
case FLUSH:
if (BufferUtil.hasContent(chunk)) {
response+=BufferUtil.toString(chunk);
chunk.position(chunk.limit());
}
if (BufferUtil.hasContent(buffer)) {
response+=BufferUtil.toString(buffer);
buffer.position(buffer.limit());
}
break;
case OK:
break mainLoop;
default :
throw new IllegalStateException(gen.toString());
}
}
}
