{
  ServerSessionFrameListener serverSessionFrameListener=new ServerSessionFrameListener.Adapter(){
    @Override public Stream.FrameListener onSyn(    Stream stream,    SynInfo synInfo){
      stream.reply(new ReplyInfo(synInfo.getHeaders(),false));
      return new Stream.FrameListener.Adapter(){
        @Override public void onData(        Stream stream,        DataInfo dataInfo){
          ByteBuffer buffer=ByteBuffer.allocateDirect(dataInfo.getBytesCount());
          dataInfo.getBytes(buffer);
          Assert.assertTrue(dataInfo.isConsumed());
          buffer.flip();
          stream.data(new ByteBufferDataInfo(buffer,true));
        }
      }
;
    }
  }
;
  final Session session=startClient(startServer(serverSessionFrameListener),null);
  final int iterations=50;
  final int count=50;
  final short version=2;
  final Headers headers=new Headers();
  headers.put("method","get");
  headers.put("path","/");
  headers.put("version","http/1.1");
  headers.put("host","localhost:8080");
  headers.put("content-type","application/octet-stream");
  final CountDownLatch latch=new CountDownLatch(count * iterations);
  session.addListener(new Session.StreamListener.Adapter(){
    @Override public void onStreamClosed(    Stream stream){
      latch.countDown();
    }
  }
);
  List<Callable<Object>> tasks=new ArrayList<>();
  for (int i=0; i < count; ++i) {
    tasks.add(new Callable<Object>(){
      @Override public Object call() throws Exception {
        process(session,version,headers,iterations);
        return null;
      }
    }
);
  }
  ExecutorService threadPool=Executors.newFixedThreadPool(count);
  List<Future<Object>> futures=threadPool.invokeAll(tasks);
  for (  Future<Object> future : futures)   future.get();
  Assert.assertTrue(latch.await(count * iterations * 100,TimeUnit.MILLISECONDS));
  threadPool.shutdown();
}
