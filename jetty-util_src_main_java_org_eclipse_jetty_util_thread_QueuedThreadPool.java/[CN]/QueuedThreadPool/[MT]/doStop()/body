{
  super.doStop();
  long start=System.currentTimeMillis();
  long timeout=getStopTimeout();
  BlockingQueue<Runnable> jobs=getQueue();
  if (timeout <= 0)   jobs.clear();
  Runnable noop=new Runnable(){
    @Override public void run(){
    }
  }
;
  for (int i=_threadsStarted.get(); i-- > 0; )   jobs.offer(noop);
  long stopby=System.currentTimeMillis() + timeout / 2;
  for (  Thread thread : _threads) {
    long canwait=stopby - System.currentTimeMillis();
    if (canwait > 0)     thread.join(canwait);
  }
  if (_threadsStarted.get() > 0)   for (  Thread thread : _threads)   thread.interrupt();
  stopby=System.currentTimeMillis() + timeout / 2;
  for (  Thread thread : _threads) {
    long canwait=stopby - System.currentTimeMillis();
    if (canwait > 0)     thread.join(canwait);
  }
  Thread.yield();
  int size=_threads.size();
  if (size > 0) {
    LOG.warn("{} threads could not be stopped",size);
    if (size <= Runtime.getRuntime().availableProcessors() || LOG.isDebugEnabled()) {
      for (      Thread unstopped : _threads) {
        StringBuilder dmp=new StringBuilder();
        for (        StackTraceElement element : unstopped.getStackTrace()) {
          dmp.append(StringUtil.__LINE_SEPARATOR).append("\tat ").append(element);
        }
        LOG.debug("Couldn't stop {}{}",unstopped,dmp.toString());
      }
    }
  }
synchronized (_joinLock) {
    _joinLock.notifyAll();
  }
}
