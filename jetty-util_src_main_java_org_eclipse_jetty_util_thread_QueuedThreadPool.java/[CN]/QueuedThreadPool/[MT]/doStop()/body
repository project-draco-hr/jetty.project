{
  super.doStop();
  long start=System.currentTimeMillis();
  while (_threadsStarted.get() > 0 && (System.currentTimeMillis() - start) < (_maxStopTime / 2))   Thread.sleep(1);
  _jobs.clear();
  Runnable noop=new Runnable(){
    public void run(){
    }
  }
;
  for (int i=_threadsIdle.get(); i-- > 0; )   _jobs.offer(noop);
  Thread.yield();
  if (_threadsStarted.get() > 0)   for (  Thread thread : _threads)   thread.interrupt();
  while (_threadsStarted.get() > 0 && (System.currentTimeMillis() - start) < _maxStopTime) {
    Thread.sleep(1);
  }
  Thread.yield();
  int size=_threads.size();
  if (size > 0) {
    LOG.warn("{} threads could not be stopped",size);
    if (size == 1 || LOG.isDebugEnabled()) {
      for (      Thread unstopped : _threads) {
        StringBuilder dmp=new StringBuilder();
        for (        StackTraceElement element : unstopped.getStackTrace()) {
          dmp.append(StringUtil.__LINE_SEPARATOR).append("\tat ").append(element);
        }
        LOG.debug("Couldn't stop {}{}",unstopped,dmp.toString());
      }
    }
  }
synchronized (_joinLock) {
    _joinLock.notifyAll();
  }
}
