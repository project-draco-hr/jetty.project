{
  super.doStop();
  long timeout=getStopTimeout();
  BlockingQueue<Runnable> jobs=getQueue();
  if (timeout <= 0)   jobs.clear();
  Runnable noop=new Runnable(){
    @Override public void run(){
    }
  }
;
  for (int i=_threadsStarted.get(); i-- > 0; )   jobs.offer(noop);
  long stopby=System.nanoTime() + TimeUnit.MILLISECONDS.toNanos(timeout) / 2;
  for (  Thread thread : _threads) {
    long canwait=TimeUnit.NANOSECONDS.toMillis(stopby - System.nanoTime());
    if (canwait > 0)     thread.join(canwait);
  }
  if (_threadsStarted.get() > 0)   for (  Thread thread : _threads)   thread.interrupt();
  stopby=System.nanoTime() + TimeUnit.MILLISECONDS.toNanos(timeout) / 2;
  for (  Thread thread : _threads) {
    long canwait=TimeUnit.NANOSECONDS.toMillis(stopby - System.nanoTime());
    if (canwait > 0)     thread.join(canwait);
  }
  Thread.yield();
  int size=_threads.size();
  if (size > 0) {
    Thread.yield();
    if (LOG.isDebugEnabled()) {
      for (      Thread unstopped : _threads) {
        StringBuilder dmp=new StringBuilder();
        for (        StackTraceElement element : unstopped.getStackTrace()) {
          dmp.append(StringUtil.__LINE_SEPARATOR).append("\tat ").append(element);
        }
        LOG.warn("Couldn't stop {}{}",unstopped,dmp.toString());
      }
    }
 else {
      for (      Thread unstopped : _threads)       LOG.warn("{} Couldn't stop {}",this,unstopped);
    }
  }
synchronized (_joinLock) {
    _joinLock.notifyAll();
  }
}
