{
  try {
switch (_state) {
case START:
      _version=null;
    _method=null;
  _methodString=null;
_uri=null;
_endOfContent=EndOfContent.UNKNOWN_CONTENT;
_header=null;
quickStart(buffer);
break;
case CONTENT:
if (_contentPosition == _contentLength) {
setState(State.END);
if (_handler.messageComplete(_contentPosition)) return true;
}
break;
case END:
return false;
case CLOSED:
if (BufferUtil.hasContent(buffer)) {
int len=buffer.remaining();
_headerBytes+=len;
if (_headerBytes > _maxHeaderBytes) {
Thread.sleep(100);
String chars=BufferUtil.toDetailString(buffer);
BufferUtil.clear(buffer);
throw new IllegalStateException(String.format("%s %d/%d data when CLOSED:%s",this,len,_headerBytes,chars));
}
BufferUtil.clear(buffer);
}
return false;
}
if (_state.ordinal() < State.HEADER.ordinal()) if (parseLine(buffer)) return true;
if (_state.ordinal() < State.END.ordinal()) if (parseHeaders(buffer)) return true;
if (_responseStatus > 0 && _headResponse) {
setState(State.END);
if (_handler.messageComplete(_contentLength)) return true;
}
byte ch;
while (_state.ordinal() > State.END.ordinal() && buffer.hasRemaining()) {
if (_eol == HttpTokens.CARRIAGE_RETURN && buffer.get(buffer.position()) == HttpTokens.LINE_FEED) {
_eol=buffer.get();
continue;
}
_eol=0;
switch (_state) {
case EOF_CONTENT:
_contentChunk=buffer.asReadOnlyBuffer();
_contentPosition+=_contentChunk.remaining();
buffer.position(buffer.position() + _contentChunk.remaining());
if (_handler.content(_contentChunk)) return true;
break;
case CONTENT:
{
long remaining=_contentLength - _contentPosition;
if (remaining == 0) {
setState(State.END);
if (_handler.messageComplete(_contentPosition)) return true;
}
 else {
_contentChunk=buffer.asReadOnlyBuffer();
if (_contentChunk.remaining() > remaining) {
_contentChunk.limit(_contentChunk.position() + (int)remaining);
}
_contentPosition+=_contentChunk.remaining();
buffer.position(buffer.position() + _contentChunk.remaining());
if (_handler.content(_contentChunk)) return true;
if (_contentPosition == _contentLength) {
setState(State.END);
if (_handler.messageComplete(_contentPosition)) return true;
}
}
break;
}
case CHUNKED_CONTENT:
{
ch=buffer.get(buffer.position());
if (ch == HttpTokens.CARRIAGE_RETURN || ch == HttpTokens.LINE_FEED) _eol=buffer.get();
 else if (ch <= HttpTokens.SPACE) buffer.get();
 else {
_chunkLength=0;
_chunkPosition=0;
setState(State.CHUNK_SIZE);
}
break;
}
case CHUNK_SIZE:
{
ch=buffer.get();
if (ch == HttpTokens.CARRIAGE_RETURN || ch == HttpTokens.LINE_FEED) {
_eol=ch;
if (_chunkLength == 0) {
if (_eol == HttpTokens.CARRIAGE_RETURN && buffer.hasRemaining() && buffer.get(buffer.position()) == HttpTokens.LINE_FEED) _eol=buffer.get();
setState(State.END);
if (_handler.messageComplete(_contentPosition)) return true;
}
 else setState(State.CHUNK);
}
 else if (ch <= HttpTokens.SPACE || ch == HttpTokens.SEMI_COLON) setState(State.CHUNK_PARAMS);
 else if (ch >= '0' && ch <= '9') _chunkLength=_chunkLength * 16 + (ch - '0');
 else if (ch >= 'a' && ch <= 'f') _chunkLength=_chunkLength * 16 + (10 + ch - 'a');
 else if (ch >= 'A' && ch <= 'F') _chunkLength=_chunkLength * 16 + (10 + ch - 'A');
 else throw new IOException("bad chunk char: " + ch);
break;
}
case CHUNK_PARAMS:
{
ch=buffer.get();
if (ch == HttpTokens.CARRIAGE_RETURN || ch == HttpTokens.LINE_FEED) {
_eol=ch;
if (_chunkLength == 0) {
if (_eol == HttpTokens.CARRIAGE_RETURN && buffer.hasRemaining() && buffer.get(buffer.position()) == HttpTokens.LINE_FEED) _eol=buffer.get();
setState(State.END);
if (_handler.messageComplete(_contentPosition)) return true;
}
 else setState(State.CHUNK);
}
break;
}
case CHUNK:
{
int remaining=_chunkLength - _chunkPosition;
if (remaining == 0) {
setState(State.CHUNKED_CONTENT);
}
 else {
_contentChunk=buffer.asReadOnlyBuffer();
if (_contentChunk.remaining() > remaining) _contentChunk.limit(_contentChunk.position() + remaining);
remaining=_contentChunk.remaining();
_contentPosition+=remaining;
_chunkPosition+=remaining;
buffer.position(buffer.position() + remaining);
if (_handler.content(_contentChunk)) return true;
}
break;
}
}
}
return false;
}
 catch (Exception e) {
BufferUtil.clear(buffer);
if (isClosed()) {
LOG.debug(e);
if (e instanceof IllegalStateException) throw (IllegalStateException)e;
throw new IllegalStateException(e);
}
LOG.warn("badMessage: " + e.toString() + " for "+ _handler);
LOG.debug(e);
badMessage(buffer,HttpStatus.BAD_REQUEST_400,null);
return true;
}
}
