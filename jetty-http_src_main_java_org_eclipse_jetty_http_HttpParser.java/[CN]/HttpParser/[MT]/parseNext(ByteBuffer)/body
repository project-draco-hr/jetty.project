{
  if (LOG.isDebugEnabled())   LOG.debug("parseNext s={} {}",_state,BufferUtil.toDetailString(buffer));
  try {
    boolean handle=false;
    if (_state == State.START) {
      _version=null;
      _method=null;
      _methodString=null;
      _endOfContent=EndOfContent.UNKNOWN_CONTENT;
      _header=null;
      handle=quickStart(buffer);
    }
    if (!handle && _state.ordinal() >= State.START.ordinal() && _state.ordinal() < State.HEADER.ordinal())     handle=parseLine(buffer);
    if (!handle && _state.ordinal() >= State.HEADER.ordinal() && _state.ordinal() < State.CONTENT.ordinal())     handle=parseHeaders(buffer);
    if (!handle && _state.ordinal() >= State.CONTENT.ordinal() && _state.ordinal() < State.END.ordinal()) {
      if (_responseStatus > 0 && _headResponse) {
        setState(State.END);
        handle=_handler.messageComplete();
      }
 else       handle=parseContent(buffer);
    }
    if (_state == State.END) {
      while (buffer.remaining() > 0 && buffer.get(buffer.position()) <= HttpTokens.SPACE)       buffer.get();
    }
 else     if (_state == State.CLOSED) {
      if (BufferUtil.hasContent(buffer)) {
        _headerBytes+=buffer.remaining();
        BufferUtil.clear(buffer);
        if (_headerBytes > _maxHeaderBytes) {
          throw new IllegalStateException("too much data after closed");
        }
      }
    }
    if (_eof && !buffer.hasRemaining()) {
switch (_state) {
case CLOSED:
        break;
case END:
      setState(State.CLOSED);
    break;
case EOF_CONTENT:
  handle=_handler.messageComplete() || handle;
setState(State.CLOSED);
break;
case CONTENT:
case CHUNKED_CONTENT:
case CHUNK_SIZE:
case CHUNK_PARAMS:
case CHUNK:
_handler.earlyEOF();
setState(State.CLOSED);
break;
default :
_handler.badMessage(400,null);
setState(State.CLOSED);
break;
}
}
return handle;
}
 catch (BadMessage e) {
BufferUtil.clear(buffer);
LOG.warn("badMessage: " + e._code + (e._message != null ? " " + e._message : "")+ " for "+ _handler);
LOG.debug(e);
setState(State.CLOSED);
_handler.badMessage(e._code,e._message);
return false;
}
catch (Exception e) {
BufferUtil.clear(buffer);
LOG.warn("badMessage: " + e.toString() + " for "+ _handler);
LOG.debug(e);
if (_state.ordinal() <= State.END.ordinal()) {
setState(State.CLOSED);
_handler.badMessage(400,null);
}
 else {
_handler.earlyEOF();
setState(State.CLOSED);
}
return false;
}
}
