{
  if (DEBUG)   LOG.debug("parseNext s={} {}",_state,BufferUtil.toDetailString(buffer));
  try {
    if (_state == State.START) {
      _version=null;
      _method=null;
      _methodString=null;
      _endOfContent=EndOfContent.UNKNOWN_CONTENT;
      _header=null;
      if (quickStart(buffer))       return true;
    }
    if (_state.ordinal() >= State.START.ordinal() && _state.ordinal() < State.HEADER.ordinal()) {
      if (parseLine(buffer))       return true;
    }
    if (_state.ordinal() >= State.HEADER.ordinal() && _state.ordinal() < State.CONTENT.ordinal()) {
      if (parseHeaders(buffer))       return true;
    }
    if (_state.ordinal() >= State.CONTENT.ordinal() && _state.ordinal() < State.END.ordinal()) {
      if (_responseStatus > 0 && _headResponse) {
        setState(State.END);
        if (_handler.messageComplete())         return true;
      }
 else {
        if (parseContent(buffer))         return true;
      }
    }
    if (_state == State.END) {
      while (buffer.remaining() > 0 && buffer.get(buffer.position()) <= HttpTokens.SPACE)       buffer.get();
    }
 else     if (_state == State.CLOSED) {
      if (BufferUtil.hasContent(buffer)) {
        _headerBytes+=buffer.remaining();
        BufferUtil.clear(buffer);
        if (_headerBytes > _maxHeaderBytes) {
          throw new IllegalStateException("too much data after closed");
        }
      }
    }
    if (_eof && !buffer.hasRemaining()) {
switch (_state) {
case CLOSED:
        break;
case START:
      setState(State.CLOSED);
    _handler.earlyEOF();
  break;
case END:
setState(State.CLOSED);
break;
case EOF_CONTENT:
setState(State.CLOSED);
return _handler.messageComplete();
case CONTENT:
case CHUNKED_CONTENT:
case CHUNK_SIZE:
case CHUNK_PARAMS:
case CHUNK:
setState(State.CLOSED);
_handler.earlyEOF();
break;
default :
if (DEBUG) LOG.debug("{} EOF in {}",this,_state);
setState(State.CLOSED);
_handler.badMessage(400,null);
break;
}
}
return false;
}
 catch (BadMessageException e) {
BufferUtil.clear(buffer);
Throwable cause=e.getCause();
boolean stack=LOG.isDebugEnabled() || (!(cause instanceof NumberFormatException) && (cause instanceof RuntimeException || cause instanceof Error));
if (stack) LOG.warn("bad HTTP parsed: " + e._code + (e.getReason() != null ? " " + e.getReason() : "")+ " for "+ _handler,e);
 else LOG.warn("bad HTTP parsed: " + e._code + (e.getReason() != null ? " " + e.getReason() : "")+ " for "+ _handler);
setState(State.CLOSED);
_handler.badMessage(e.getCode(),e.getReason());
return false;
}
catch (NumberFormatException|IllegalStateException e) {
BufferUtil.clear(buffer);
LOG.warn("parse exception: " + e.toString() + " for "+ _handler);
if (DEBUG) LOG.debug(e);
if (_state.ordinal() <= State.END.ordinal()) {
setState(State.CLOSED);
_handler.badMessage(400,null);
}
 else {
_handler.earlyEOF();
setState(State.CLOSED);
}
return false;
}
catch (Exception|Error e) {
BufferUtil.clear(buffer);
LOG.warn("parse exception: " + e.toString() + " for "+ _handler,e);
if (_state.ordinal() <= State.END.ordinal()) {
setState(State.CLOSED);
_handler.badMessage(400,null);
}
 else {
_handler.earlyEOF();
setState(State.CLOSED);
}
return false;
}
}
