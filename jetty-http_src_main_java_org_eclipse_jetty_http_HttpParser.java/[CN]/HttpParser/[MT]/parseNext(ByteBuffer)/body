{
  try {
    if (_state == State.END)     return false;
    if (_state == State.CONTENT && _contentPosition == _contentLength) {
      _state=State.END;
      if (_handler.messageComplete(_contentPosition))       return true;
    }
    if (_state == State.START) {
      _version=null;
      _method=null;
      _methodString=null;
      _uri=null;
      _endOfContent=EndOfContent.UNKNOWN_CONTENT;
      _header=null;
      quickStart(buffer);
    }
    if (_state.ordinal() < State.HEADER.ordinal())     if (parseLine(buffer))     return true;
    if (_state.ordinal() < State.END.ordinal())     if (parseHeaders(buffer))     return true;
    if (_responseStatus > 0 && _headResponse) {
      _state=_persistent || (_responseStatus >= 100 && _responseStatus < 200) ? State.END : State.SEEKING_EOF;
      if (_handler.messageComplete(_contentLength))       return true;
    }
    byte ch;
    while (_state.ordinal() > State.END.ordinal() && buffer.hasRemaining()) {
      if (_eol == HttpTokens.CARRIAGE_RETURN && buffer.get(buffer.position()) == HttpTokens.LINE_FEED) {
        _eol=buffer.get();
        continue;
      }
      _eol=0;
switch (_state) {
case EOF_CONTENT:
        _contentChunk=buffer.asReadOnlyBuffer();
      _contentPosition+=_contentChunk.remaining();
    buffer.position(buffer.position() + _contentChunk.remaining());
  if (_handler.content(_contentChunk))   return true;
break;
case CONTENT:
{
long remaining=_contentLength - _contentPosition;
if (remaining == 0) {
  _state=_persistent ? State.END : State.SEEKING_EOF;
  if (_handler.messageComplete(_contentPosition))   return true;
}
 else {
  _contentChunk=buffer.asReadOnlyBuffer();
  if (_contentChunk.remaining() > remaining) {
    _contentChunk.limit(_contentChunk.position() + (int)remaining);
  }
  _contentPosition+=_contentChunk.remaining();
  buffer.position(buffer.position() + _contentChunk.remaining());
  if (_handler.content(_contentChunk))   return true;
  if (_contentPosition == _contentLength) {
    _state=_persistent ? State.END : State.SEEKING_EOF;
    if (_handler.messageComplete(_contentPosition))     return true;
  }
}
break;
}
case CHUNKED_CONTENT:
{
ch=buffer.get(buffer.position());
if (ch == HttpTokens.CARRIAGE_RETURN || ch == HttpTokens.LINE_FEED) _eol=buffer.get();
 else if (ch <= HttpTokens.SPACE) buffer.get();
 else {
_chunkLength=0;
_chunkPosition=0;
_state=State.CHUNK_SIZE;
}
break;
}
case CHUNK_SIZE:
{
ch=buffer.get();
if (ch == HttpTokens.CARRIAGE_RETURN || ch == HttpTokens.LINE_FEED) {
_eol=ch;
if (_chunkLength == 0) {
if (_eol == HttpTokens.CARRIAGE_RETURN && buffer.hasRemaining() && buffer.get(buffer.position()) == HttpTokens.LINE_FEED) _eol=buffer.get();
_state=_persistent ? State.END : State.SEEKING_EOF;
if (_handler.messageComplete(_contentPosition)) return true;
}
 else _state=State.CHUNK;
}
 else if (ch <= HttpTokens.SPACE || ch == HttpTokens.SEMI_COLON) _state=State.CHUNK_PARAMS;
 else if (ch >= '0' && ch <= '9') _chunkLength=_chunkLength * 16 + (ch - '0');
 else if (ch >= 'a' && ch <= 'f') _chunkLength=_chunkLength * 16 + (10 + ch - 'a');
 else if (ch >= 'A' && ch <= 'F') _chunkLength=_chunkLength * 16 + (10 + ch - 'A');
 else throw new IOException("bad chunk char: " + ch);
break;
}
case CHUNK_PARAMS:
{
ch=buffer.get();
if (ch == HttpTokens.CARRIAGE_RETURN || ch == HttpTokens.LINE_FEED) {
_eol=ch;
if (_chunkLength == 0) {
if (_eol == HttpTokens.CARRIAGE_RETURN && buffer.hasRemaining() && buffer.get(buffer.position()) == HttpTokens.LINE_FEED) _eol=buffer.get();
_state=_persistent ? State.END : State.SEEKING_EOF;
if (_handler.messageComplete(_contentPosition)) return true;
}
 else _state=State.CHUNK;
}
break;
}
case CHUNK:
{
int remaining=_chunkLength - _chunkPosition;
if (remaining == 0) {
_state=State.CHUNKED_CONTENT;
}
 else {
_contentChunk=buffer.asReadOnlyBuffer();
if (_contentChunk.remaining() > remaining) _contentChunk.limit(_contentChunk.position() + remaining);
remaining=_contentChunk.remaining();
_contentPosition+=remaining;
_chunkPosition+=remaining;
buffer.position(buffer.position() + remaining);
if (_handler.content(_contentChunk)) return true;
}
break;
}
case SEEKING_EOF:
{
buffer.clear().limit(0);
break;
}
}
}
return false;
}
 catch (Exception e) {
LOG.debug(e);
_handler.badMessage(e.toString());
return true;
}
}
