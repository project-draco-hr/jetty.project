{
  boolean return_from_parse=false;
  while (_state.ordinal() < State.HEADER.ordinal() && buffer.hasRemaining() && !return_from_parse) {
    byte ch=buffer.get();
    if (_maxHeaderBytes > 0 && ++_headerBytes > _maxHeaderBytes) {
      if (_state == State.URI) {
        LOG.warn("URI is too large >" + _maxHeaderBytes);
        badMessage(buffer,HttpStatus.REQUEST_URI_TOO_LONG_414,null);
      }
 else {
        if (_requestHandler != null)         LOG.warn("request is too large >" + _maxHeaderBytes);
 else         LOG.warn("response is too large >" + _maxHeaderBytes);
        badMessage(buffer,HttpStatus.REQUEST_ENTITY_TOO_LARGE_413,null);
      }
      return true;
    }
    if (_eol == HttpTokens.CARRIAGE_RETURN && ch == HttpTokens.LINE_FEED) {
      _eol=HttpTokens.LINE_FEED;
      continue;
    }
    _eol=0;
switch (_state) {
case METHOD:
      if (ch == HttpTokens.SPACE) {
        _methodString=takeString();
        HttpMethod method=HttpMethod.CACHE.get(_methodString);
        if (method != null)         _methodString=method.asString();
        setState(State.SPACE1);
      }
 else       if (ch < HttpTokens.SPACE && ch >= 0) {
        badMessage(buffer,HttpStatus.BAD_REQUEST_400,"No URI");
        return true;
      }
 else       _string.append((char)ch);
    break;
case RESPONSE_VERSION:
  if (ch == HttpTokens.SPACE) {
    String version=takeString();
    _version=HttpVersion.CACHE.get(version);
    if (_version == null) {
      badMessage(buffer,HttpStatus.BAD_REQUEST_400,"Unknown Version");
      return true;
    }
    setState(State.SPACE1);
  }
 else   if (ch < HttpTokens.SPACE && ch >= 0) {
    badMessage(buffer,HttpStatus.BAD_REQUEST_400,"No Status");
    return true;
  }
 else   _string.append((char)ch);
break;
case SPACE1:
if (ch > HttpTokens.SPACE || ch < 0) {
if (_responseHandler != null) {
  setState(State.STATUS);
  _responseStatus=ch - '0';
}
 else {
  _uri.clear();
  setState(State.URI);
  if (buffer.hasArray()) {
    byte[] array=buffer.array();
    int p=buffer.arrayOffset() + buffer.position();
    int l=buffer.arrayOffset() + buffer.limit();
    int i=p;
    while (i < l && array[i] > HttpTokens.SPACE)     i++;
    int len=i - p;
    _headerBytes+=len;
    if (_maxHeaderBytes > 0 && ++_headerBytes > _maxHeaderBytes) {
      LOG.warn("URI is too large >" + _maxHeaderBytes);
      badMessage(buffer,HttpStatus.REQUEST_URI_TOO_LONG_414,null);
      return true;
    }
    if (_uri.remaining() <= len) {
      ByteBuffer uri=ByteBuffer.allocate(_uri.capacity() + 2 * len);
      _uri.flip();
      uri.put(_uri);
      _uri=uri;
    }
    _uri.put(array,p - 1,len + 1);
    buffer.position(i - buffer.arrayOffset());
  }
 else   _uri.put(ch);
}
}
 else if (ch < HttpTokens.SPACE) {
badMessage(buffer,HttpStatus.BAD_REQUEST_400,_requestHandler != null ? "No URI" : "No Status");
return true;
}
break;
case STATUS:
if (ch == HttpTokens.SPACE) {
setState(State.SPACE2);
}
 else if (ch >= '0' && ch <= '9') {
_responseStatus=_responseStatus * 10 + (ch - '0');
}
 else if (ch < HttpTokens.SPACE && ch >= 0) {
return_from_parse|=_responseHandler.startResponse(_version,_responseStatus,null);
_eol=ch;
setState(State.HEADER);
}
 else {
throw new IllegalStateException();
}
break;
case URI:
if (ch == HttpTokens.SPACE) {
setState(State.SPACE2);
}
 else if (ch < HttpTokens.SPACE && ch >= 0) {
_uri.flip();
return_from_parse|=_requestHandler.startRequest(_method,_methodString,_uri,null);
setState(State.END);
BufferUtil.clear(buffer);
return_from_parse|=_handler.headerComplete();
return_from_parse|=_handler.messageComplete();
}
 else {
if (!_uri.hasRemaining()) {
ByteBuffer uri=ByteBuffer.allocate(_uri.capacity() * 2);
_uri.flip();
uri.put(_uri);
_uri=uri;
}
_uri.put(ch);
}
break;
case SPACE2:
if (ch > HttpTokens.SPACE || ch < 0) {
_string.setLength(0);
_string.append((char)ch);
if (_responseHandler != null) {
_length=1;
setState(State.REASON);
}
 else {
setState(State.REQUEST_VERSION);
if (buffer.position() > 0 && buffer.hasArray()) {
_version=HttpVersion.lookAheadGet(buffer.array(),buffer.arrayOffset() + buffer.position() - 1,buffer.arrayOffset() + buffer.limit());
if (_version != null) {
_string.setLength(0);
buffer.position(buffer.position() + _version.asString().length() - 1);
_eol=buffer.get();
setState(State.HEADER);
_uri.flip();
return_from_parse|=_requestHandler.startRequest(_method,_methodString,_uri,_version);
}
}
}
}
 else if (ch < HttpTokens.SPACE) {
if (_responseHandler != null) {
return_from_parse|=_responseHandler.startResponse(_version,_responseStatus,null);
_eol=ch;
setState(State.HEADER);
}
 else {
_uri.flip();
return_from_parse|=_requestHandler.startRequest(_method,_methodString,_uri,null);
setState(State.END);
BufferUtil.clear(buffer);
return_from_parse|=_handler.headerComplete();
return_from_parse|=_handler.messageComplete();
}
}
break;
case REQUEST_VERSION:
if (ch == HttpTokens.CARRIAGE_RETURN || ch == HttpTokens.LINE_FEED) {
String version=takeString();
_version=HttpVersion.CACHE.get(version);
if (_version == null) {
badMessage(buffer,HttpStatus.BAD_REQUEST_400,"Unknown Version");
return true;
}
if (_version.getVersion() >= HttpVersion.HTTP_1_1.getVersion()) {
int header_cache=_handler.getHeaderCacheSize();
if (header_cache > 0) _connectionFields=new ArrayTernaryTrie<>(header_cache);
}
_eol=ch;
setState(State.HEADER);
_uri.flip();
return_from_parse|=_requestHandler.startRequest(_method,_methodString,_uri,_version);
continue;
}
 else _string.append((char)ch);
break;
case REASON:
if (ch == HttpTokens.CARRIAGE_RETURN || ch == HttpTokens.LINE_FEED) {
String reason=takeLengthString();
_eol=ch;
setState(State.HEADER);
return_from_parse|=_responseHandler.startResponse(_version,_responseStatus,reason);
continue;
}
 else {
_string.append((char)ch);
if (ch != ' ' && ch != '\t') _length=_string.length();
}
break;
default :
throw new IllegalStateException(_state.toString());
}
}
return return_from_parse;
}
