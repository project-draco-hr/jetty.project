{
  boolean return_from_parse=false;
  while (_state.ordinal() < State.END.ordinal() && buffer.hasRemaining() && !return_from_parse) {
    byte ch=buffer.get();
    if (_maxHeaderBytes > 0 && ++_headerBytes > _maxHeaderBytes) {
      LOG.warn("Header is too large >" + _maxHeaderBytes);
      badMessage(buffer,HttpStatus.REQUEST_ENTITY_TOO_LARGE_413,null);
      return true;
    }
    if (_eol == HttpTokens.CARRIAGE_RETURN && ch == HttpTokens.LINE_FEED) {
      _eol=HttpTokens.LINE_FEED;
      continue;
    }
    _eol=0;
switch (_state) {
case HEADER:
switch (ch) {
case HttpTokens.COLON:
case HttpTokens.SPACE:
case HttpTokens.TAB:
{
          _length=-1;
          _string.setLength(0);
          setState(State.HEADER_VALUE);
          break;
        }
default :
{
        if (_headerString != null || _valueString != null) {
          if (_header != null) {
switch (_header) {
case CONTENT_LENGTH:
              if (_endOfContent != EndOfContent.CHUNKED_CONTENT && _responseStatus != 304 && _responseStatus != 204 && (_responseStatus < 100 || _responseStatus >= 200)) {
                try {
                  _contentLength=Long.parseLong(_valueString);
                }
 catch (                NumberFormatException e) {
                  LOG.ignore(e);
                  badMessage(buffer,HttpStatus.BAD_REQUEST_400,"Bad Content-Length");
                  return true;
                }
                if (_contentLength <= 0)                 _endOfContent=EndOfContent.NO_CONTENT;
 else                 _endOfContent=EndOfContent.CONTENT_LENGTH;
              }
            break;
case TRANSFER_ENCODING:
          if (_value == HttpHeaderValue.CHUNKED)           _endOfContent=EndOfContent.CHUNKED_CONTENT;
 else {
            if (_valueString.endsWith(HttpHeaderValue.CHUNKED.toString()))             _endOfContent=EndOfContent.CHUNKED_CONTENT;
 else             if (_valueString.indexOf(HttpHeaderValue.CHUNKED.toString()) >= 0) {
              badMessage(buffer,HttpStatus.BAD_REQUEST_400,"Bad chunking");
              return true;
            }
          }
        break;
case HOST:
      _host=true;
    String host=_valueString;
  int port=0;
if (host == null || host.length() == 0) {
  badMessage(buffer,HttpStatus.BAD_REQUEST_400,"Bad Host header");
  return true;
}
loop: for (int i=host.length(); i-- > 0; ) {
char c2=(char)(0xff & host.charAt(i));
switch (c2) {
case ']':
  break loop;
case ':':
try {
  port=StringUtil.toInt(host.substring(i + 1));
}
 catch (NumberFormatException e) {
  LOG.debug(e);
  badMessage(buffer,HttpStatus.BAD_REQUEST_400,"Bad Host header");
  return true;
}
host=host.substring(0,i);
break loop;
}
}
if (_requestHandler != null) _requestHandler.parsedHostHeader(host,port);
}
}
return_from_parse|=_handler.parsedHeader(_header,_headerString,_valueString);
}
_headerString=_valueString=null;
_header=null;
_value=null;
if (ch == HttpTokens.CARRIAGE_RETURN || ch == HttpTokens.LINE_FEED) {
consumeCRLF(ch,buffer);
_contentPosition=0;
if (!_host && _version != HttpVersion.HTTP_1_0 && _requestHandler != null) {
badMessage(buffer,HttpStatus.BAD_REQUEST_400,"No Host");
return true;
}
if (_endOfContent == EndOfContent.UNKNOWN_CONTENT) {
if (_responseStatus == 0 || _responseStatus == 304 || _responseStatus == 204 || _responseStatus < 200) _endOfContent=EndOfContent.NO_CONTENT;
 else _endOfContent=EndOfContent.EOF_CONTENT;
}
switch (_endOfContent) {
case EOF_CONTENT:
setState(State.EOF_CONTENT);
return_from_parse|=_handler.headerComplete();
break;
case CHUNKED_CONTENT:
setState(State.CHUNKED_CONTENT);
return_from_parse|=_handler.headerComplete();
break;
case NO_CONTENT:
return_from_parse|=_handler.headerComplete();
setState(State.END);
return_from_parse|=_handler.messageComplete();
break;
default :
setState(State.CONTENT);
return_from_parse|=_handler.headerComplete();
break;
}
}
 else {
if (buffer.remaining() > 6 && buffer.hasArray()) {
_header=HttpHeader.lookAheadGet(buffer.array(),buffer.arrayOffset() + buffer.position() - 1,buffer.arrayOffset() + buffer.limit());
if (_header != null) {
_headerString=_header.asString();
buffer.position(buffer.position() + _headerString.length());
setState(buffer.get(buffer.position() - 1) == ':' ? State.HEADER_VALUE : State.HEADER_NAME);
break;
}
}
setState(State.HEADER_NAME);
_string.setLength(0);
_string.append((char)ch);
_length=1;
}
}
}
break;
case HEADER_NAME:
switch (ch) {
case HttpTokens.CARRIAGE_RETURN:
case HttpTokens.LINE_FEED:
consumeCRLF(ch,buffer);
_headerString=takeLengthString();
_header=HttpHeader.CACHE.get(_headerString);
setState(State.HEADER);
break;
case HttpTokens.COLON:
if (_headerString == null) {
_headerString=takeLengthString();
_header=HttpHeader.CACHE.get(_headerString);
}
setState(State.HEADER_VALUE);
break;
case HttpTokens.SPACE:
case HttpTokens.TAB:
_string.append((char)ch);
break;
default :
{
if (_header != null) {
_string.setLength(0);
_string.append(_header.asString());
_string.append(' ');
_length=_string.length();
_header=null;
_headerString=null;
}
_string.append((char)ch);
_length=_string.length();
setState(State.HEADER_IN_NAME);
}
}
break;
case HEADER_IN_NAME:
switch (ch) {
case HttpTokens.CARRIAGE_RETURN:
case HttpTokens.LINE_FEED:
consumeCRLF(ch,buffer);
_headerString=takeString();
_length=-1;
_header=HttpHeader.CACHE.get(_headerString);
setState(State.HEADER);
break;
case HttpTokens.COLON:
if (_headerString == null) {
_headerString=takeString();
_header=HttpHeader.CACHE.get(_headerString);
}
_length=-1;
setState(State.HEADER_VALUE);
break;
case HttpTokens.SPACE:
case HttpTokens.TAB:
setState(State.HEADER_NAME);
_string.append((char)ch);
break;
default :
_string.append((char)ch);
_length++;
}
break;
case HEADER_VALUE:
switch (ch) {
case HttpTokens.CARRIAGE_RETURN:
case HttpTokens.LINE_FEED:
consumeCRLF(ch,buffer);
if (_length > 0) {
if (_valueString != null) {
_value=null;
_valueString+=" " + takeLengthString();
}
 else if (HttpHeaderValue.hasKnownValues(_header)) {
_valueString=takeLengthString();
_value=HttpHeaderValue.CACHE.get(_valueString);
}
 else {
_value=null;
_valueString=takeLengthString();
}
}
setState(State.HEADER);
break;
case HttpTokens.SPACE:
case HttpTokens.TAB:
break;
default :
{
_string.append((char)ch);
_length=_string.length();
setState(State.HEADER_IN_VALUE);
}
}
break;
case HEADER_IN_VALUE:
switch (ch) {
case HttpTokens.CARRIAGE_RETURN:
case HttpTokens.LINE_FEED:
consumeCRLF(ch,buffer);
if (_length > 0) {
if (_valueString != null) {
_value=null;
_valueString+=" " + takeString();
}
 else if (HttpHeaderValue.hasKnownValues(_header)) {
_valueString=takeString();
_value=HttpHeaderValue.CACHE.get(_valueString);
}
 else {
_value=null;
_valueString=takeString();
}
_length=-1;
}
setState(State.HEADER);
break;
case HttpTokens.SPACE:
case HttpTokens.TAB:
_string.append((char)ch);
setState(State.HEADER_VALUE);
break;
default :
_string.append((char)ch);
_length++;
}
break;
default :
throw new IllegalStateException(_state.toString());
}
}
return return_from_parse;
}
