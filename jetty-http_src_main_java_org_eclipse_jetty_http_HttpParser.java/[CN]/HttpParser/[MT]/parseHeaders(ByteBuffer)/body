{
  boolean handle=false;
  while (_state.ordinal() < State.CONTENT.ordinal() && buffer.hasRemaining() && !handle) {
    byte ch=next(buffer);
    if (ch == 0)     break;
    if (_maxHeaderBytes > 0 && ++_headerBytes > _maxHeaderBytes) {
      LOG.warn("Header is too large >" + _maxHeaderBytes);
      throw new BadMessageException(HttpStatus.REQUEST_ENTITY_TOO_LARGE_413);
    }
switch (_state) {
case HEADER:
switch (ch) {
case HttpTokens.COLON:
case HttpTokens.SPACE:
case HttpTokens.TAB:
        throw new BadMessageException(HttpStatus.BAD_REQUEST_400,"Bad Continuation");
case HttpTokens.LINE_FEED:
{
        _contentPosition=0;
        if (!_host && _version != HttpVersion.HTTP_1_0 && _requestHandler != null) {
          throw new BadMessageException(HttpStatus.BAD_REQUEST_400,"No Host");
        }
        if (_responseHandler != null && (_responseStatus == 304 || _responseStatus == 204 || _responseStatus < 200))         _endOfContent=EndOfContent.NO_CONTENT;
 else         if (_endOfContent == EndOfContent.UNKNOWN_CONTENT) {
          if (_responseStatus == 0 || _responseStatus == 304 || _responseStatus == 204 || _responseStatus < 200)           _endOfContent=EndOfContent.NO_CONTENT;
 else           _endOfContent=EndOfContent.EOF_CONTENT;
        }
switch (_endOfContent) {
case EOF_CONTENT:
          setState(State.EOF_CONTENT);
        handle=_handler.headerComplete() || handle;
      break;
case CHUNKED_CONTENT:
    setState(State.CHUNKED_CONTENT);
  handle=_handler.headerComplete() || handle;
break;
case NO_CONTENT:
handle=_handler.headerComplete() || handle;
setState(State.END);
handle=_handler.messageComplete() || handle;
break;
default :
setState(State.CONTENT);
handle=_handler.headerComplete() || handle;
break;
}
break;
}
default :
{
if (ch <= HttpTokens.SPACE) throw new BadMessageException();
if (buffer.hasRemaining()) {
HttpField field=_connectionFields == null ? null : _connectionFields.getBest(buffer,-1,buffer.remaining());
if (field == null) field=CACHE.getBest(buffer,-1,buffer.remaining());
if (field != null) {
final String n;
final String v;
if (_strict) {
String fn=field.getName();
String fv=field.getValue();
n=BufferUtil.toString(buffer,buffer.position() - 1,fn.length(),StandardCharsets.US_ASCII);
if (fv == null) v=null;
 else {
v=BufferUtil.toString(buffer,buffer.position() + fn.length() + 1,fv.length(),StandardCharsets.ISO_8859_1);
field=new HttpField(field.getHeader(),n,v);
}
}
 else {
n=field.getName();
v=field.getValue();
}
_header=field.getHeader();
_headerString=n;
if (v == null) {
setState(State.HEADER_VALUE);
_string.setLength(0);
_length=0;
buffer.position(buffer.position() + n.length() + 1);
break;
}
 else {
int pos=buffer.position() + n.length() + v.length()+ 1;
byte b=buffer.get(pos);
if (b == HttpTokens.CARRIAGE_RETURN || b == HttpTokens.LINE_FEED) {
_field=field;
_valueString=v;
setState(State.HEADER_IN_VALUE);
if (b == HttpTokens.CARRIAGE_RETURN) {
_cr=true;
buffer.position(pos + 1);
}
 else buffer.position(pos);
break;
}
 else {
setState(State.HEADER_IN_VALUE);
setString(v);
buffer.position(pos);
break;
}
}
}
}
setState(State.HEADER_IN_NAME);
_string.setLength(0);
_string.append((char)ch);
_length=1;
}
}
break;
case HEADER_IN_NAME:
if (ch == HttpTokens.COLON) {
if (_headerString == null) {
_headerString=takeString();
_header=HttpHeader.CACHE.get(_headerString);
}
_length=-1;
setState(State.HEADER_VALUE);
break;
}
if (ch > HttpTokens.SPACE) {
if (_header != null) {
setString(_header.asString());
_header=null;
_headerString=null;
}
_string.append((char)ch);
if (ch > HttpTokens.SPACE) _length=_string.length();
break;
}
throw new IllegalCharacter(ch,buffer);
case HEADER_VALUE:
if (ch > HttpTokens.SPACE || ch < 0) {
_string.append((char)(0xff & ch));
_length=_string.length();
setState(State.HEADER_IN_VALUE);
break;
}
if (ch == HttpTokens.SPACE || ch == HttpTokens.TAB) break;
if (ch == HttpTokens.LINE_FEED) {
_value=null;
_string.setLength(0);
_valueString=null;
_length=-1;
parsedHeader();
setState(State.HEADER);
break;
}
throw new IllegalCharacter(ch,buffer);
case HEADER_IN_VALUE:
if (ch >= HttpTokens.SPACE || ch < 0 || ch == HttpTokens.TAB) {
if (_valueString != null) {
setString(_valueString);
_valueString=null;
_field=null;
}
_string.append((char)(0xff & ch));
if (ch > HttpTokens.SPACE || ch < 0) _length=_string.length();
break;
}
if (ch == HttpTokens.LINE_FEED) {
if (_length > 0) {
_value=null;
_valueString=takeString();
_length=-1;
}
parsedHeader();
setState(State.HEADER);
break;
}
throw new IllegalCharacter(ch,buffer);
default :
throw new IllegalStateException(_state.toString());
}
}
return handle;
}
