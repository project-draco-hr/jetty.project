{
  final Map<Integer,Integer> counter=new ConcurrentHashMap<>(iterations);
  final CountDownLatch requestsLatch=new CountDownLatch(2 * iterations);
  for (int i=0; i < iterations; ++i) {
    final AtomicInteger count=new AtomicInteger(2);
    final int index=i;
    counter.put(index,index);
    session.syn(new SynInfo(headers,false),new StreamFrameListener.Adapter(){
      @Override public void onReply(      Stream stream,      ReplyInfo replyInfo){
        Assert.assertEquals(2,count.getAndDecrement());
        requestsLatch.countDown();
      }
      @Override public void onData(      Stream stream,      DataInfo dataInfo){
        dataInfo.asBytes(true);
        if (dataInfo.isClose()) {
          Assert.assertEquals(1,count.getAndDecrement());
          counter.remove(index);
          requestsLatch.countDown();
        }
      }
    }
,new Promise.Adapter<Stream>(){
      @Override public void succeeded(      Stream stream){
        stream.data(new StringDataInfo("data_" + stream.getId(),true),new Callback.Adapter());
      }
    }
);
  }
  Assert.assertTrue(requestsLatch.await(iterations,TimeUnit.SECONDS));
  Assert.assertTrue(counter.toString(),counter.isEmpty());
}
