{
  final AtomicLong leaks=new AtomicLong();
  LeakTrackingByteBufferPool serverBufferPool=new LeakTrackingByteBufferPool(new ArrayByteBufferPool()){
    @Override protected void leaked(    LeakDetector.LeakInfo leakInfo){
      leaks.incrementAndGet();
    }
  }
;
  LeakTrackingByteBufferPool clientBufferPool=new LeakTrackingByteBufferPool(new MappedByteBufferPool()){
    @Override protected void leaked(    LeakDetector.LeakInfo leakInfo){
      leaks.incrementAndGet();
    }
  }
;
  ServerSessionFrameListener listener=new ServerSessionFrameListener.Adapter(){
    @Override public StreamFrameListener onSyn(    Stream stream,    SynInfo synInfo){
      stream.reply(new ReplyInfo(synInfo.getHeaders(),false),new Callback.Adapter());
      return new StreamFrameListener.Adapter(){
        @Override public void onData(        Stream stream,        DataInfo dataInfo){
          ByteBuffer buffer=dataInfo.asByteBuffer(true);
          stream.data(new ByteBufferDataInfo(buffer,dataInfo.isClose()),new Callback.Adapter());
        }
      }
;
    }
  }
;
  short spdyVersion=SPDY.V2;
  long idleTimeout=2 * TIMEOUT;
  server=newServer();
  connector=new ServerConnector(server,null,null,serverBufferPool,1,Math.max(1,Runtime.getRuntime().availableProcessors() / 2),new SPDYServerConnectionFactory(spdyVersion,listener));
  connector.setIdleTimeout(idleTimeout);
  QueuedThreadPool clientExecutor=new QueuedThreadPool();
  clientExecutor.setName(clientExecutor.getName() + "-client");
  clientFactory=new SPDYClient.Factory(clientExecutor,null,clientBufferPool,null,idleTimeout);
  final Session session=startClient(spdyVersion,startServer(spdyVersion,listener),null);
  final Thread testThread=Thread.currentThread();
  Runnable timeout=new Runnable(){
    @Override public void run(){
      logger.warn("Interrupting test, it is taking too long");
      logger.warn("SERVER: {}",server.dump());
      logger.warn("CLIENT: {}",clientFactory.dump());
      testThread.interrupt();
    }
  }
;
  final int iterations=500;
  final int count=50;
  final Fields headers=new Fields();
  headers.put("method","get");
  headers.put("url","/");
  headers.put("version","http/1.1");
  headers.put("host","localhost:8080");
  headers.put("content-type","application/octet-stream");
  final CountDownLatch latch=new CountDownLatch(count * iterations);
  session.addListener(new Session.StreamListener.Adapter(){
    @Override public void onStreamClosed(    Stream stream){
      latch.countDown();
    }
  }
);
  ExecutorService threadPool=Executors.newFixedThreadPool(count);
  List<Callable<Object>> tasks=new ArrayList<>();
  tasks.clear();
  for (int i=0; i < count; ++i) {
    tasks.add(new Callable<Object>(){
      @Override public Object call() throws Exception {
        synGetDataGet(session,headers,iterations);
        return null;
      }
    }
);
  }
  Scheduler.Task syncTimeoutTask=clientFactory.getScheduler().schedule(timeout,TIMEOUT / 2,TimeUnit.MILLISECONDS);
{
    long begin=System.nanoTime();
    List<Future<Object>> futures=threadPool.invokeAll(tasks);
    for (    Future<Object> future : futures)     future.get(iterations,TimeUnit.SECONDS);
    Assert.assertTrue(latch.await(count * iterations,TimeUnit.SECONDS));
    long end=System.nanoTime();
    System.err.printf("SYN+GET+DATA+GET completed in %d ms%n",TimeUnit.NANOSECONDS.toMillis(end - begin));
  }
  syncTimeoutTask.cancel();
  tasks.clear();
  for (int i=0; i < count; ++i) {
    tasks.add(new Callable<Object>(){
      @Override public Object call() throws Exception {
        synCompletedData(session,headers,iterations);
        return null;
      }
    }
);
  }
  Scheduler.Task asyncTimeoutTask=clientFactory.getScheduler().schedule(timeout,TIMEOUT / 2,TimeUnit.MILLISECONDS);
{
    long begin=System.nanoTime();
    List<Future<Object>> futures=threadPool.invokeAll(tasks);
    for (    Future<Object> future : futures)     future.get(iterations,TimeUnit.SECONDS);
    Assert.assertTrue(latch.await(count * iterations,TimeUnit.SECONDS));
    long end=System.nanoTime();
    System.err.printf("SYN+COMPLETED+DATA completed in %d ms%n",TimeUnit.NANOSECONDS.toMillis(end - begin));
  }
  asyncTimeoutTask.cancel();
  threadPool.shutdown();
  Assert.assertEquals(0,leaks.get());
}
