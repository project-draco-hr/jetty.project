{
  final Map<Integer,Integer> counter=new ConcurrentHashMap<>(iterations);
  final CountDownLatch latch=new CountDownLatch(2 * iterations);
  for (int i=0; i < iterations; ++i) {
    final AtomicInteger count=new AtomicInteger(2);
    final int index=i;
    counter.put(index,index);
    Stream stream=session.syn(new SynInfo(5,TimeUnit.SECONDS,headers,false,(byte)0),new StreamFrameListener.Adapter(){
      @Override public void onReply(      Stream stream,      ReplyInfo replyInfo){
        Assert.assertEquals(2,count.getAndDecrement());
        latch.countDown();
      }
      @Override public void onData(      Stream stream,      DataInfo dataInfo){
        dataInfo.asBytes(true);
        if (dataInfo.isClose()) {
          Assert.assertEquals(1,count.getAndDecrement());
          counter.remove(index);
          latch.countDown();
        }
      }
    }
);
    stream.data(new StringDataInfo(5,TimeUnit.SECONDS,"data_" + stream.getId(),true));
  }
  Assert.assertTrue(latch.await(iterations,TimeUnit.SECONDS));
  Assert.assertTrue(counter.toString(),counter.isEmpty());
}
