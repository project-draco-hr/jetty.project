{
  String str=pathSpec.toString();
  if ("".equals(str.trim())) {
    MappedEntry entry=new MappedEntry("",object);
    entry.setMapped("");
    _exactMap.put("",entry);
    return super.put("",object);
  }
  StringTokenizer tok=new StringTokenizer(str,__pathSpecSeparators);
  O old=null;
  while (tok.hasMoreTokens()) {
    String spec=tok.nextToken();
    if (!spec.startsWith("/") && !spec.startsWith("*."))     throw new IllegalArgumentException("PathSpec " + spec + ". must start with '/' or '*.'");
    old=super.put(spec,object);
    MappedEntry entry=new MappedEntry(spec,object);
    if (entry.getKey().equals(spec)) {
      if (spec.equals("/*"))       _prefixDefault=entry;
 else       if (spec.endsWith("/*")) {
        String mapped=spec.substring(0,spec.length() - 2);
        entry.setMapped(mapped);
        _prefixMap.put(mapped,entry);
        _exactMap.put(mapped,entry);
        _exactMap.put(spec.substring(0,spec.length() - 1),entry);
      }
 else       if (spec.startsWith("*."))       _suffixMap.put(spec.substring(2),entry);
 else       if (spec.equals(URIUtil.SLASH)) {
        if (_nodefault)         _exactMap.put(spec,entry);
 else {
          _default=entry;
          _defaultSingletonList=Collections.singletonList(_default);
        }
      }
 else {
        entry.setMapped(spec);
        _exactMap.put(spec,entry);
      }
    }
  }
  return old;
}
