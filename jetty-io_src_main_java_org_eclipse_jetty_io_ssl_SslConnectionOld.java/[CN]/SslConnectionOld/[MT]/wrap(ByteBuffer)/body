{
  if (_writing.get())   return false;
  final SSLEngineResult result;
  int pos=BufferUtil.flipToFill(_outNet);
  try {
    result=_engine.wrap(outApp,_outNet);
  }
  finally {
    BufferUtil.flipToFlush(_outNet,pos);
  }
  if (LOG.isDebugEnabled())   LOG.debug("{} wrap {} {} consumed={} produced={}",_session,result.getStatus(),result.getHandshakeStatus(),result.bytesConsumed(),result.bytesProduced());
switch (result.getStatus()) {
case BUFFER_UNDERFLOW:
    throw new IllegalStateException();
case BUFFER_OVERFLOW:
  break;
case OK:
if (result.getHandshakeStatus() == HandshakeStatus.FINISHED) _handshook=true;
break;
case CLOSED:
LOG.debug("wrap CLOSE {} {}",this,result);
if (result.getHandshakeStatus() == HandshakeStatus.FINISHED) _endp.close();
break;
default :
LOG.debug("{} wrap default {}",_session,result);
throw new IOException(result.toString());
}
if (BufferUtil.hasContent(_outNet) && _writing.compareAndSet(false,true)) _endp.write(null,_netWriteCallback,_outNet);
return result.bytesConsumed() > 0 || result.bytesProduced() > 0;
}
