{
  boolean direct;
  long content_length;
  if (content == null) {
    direct=false;
    content_length=resource.length();
  }
 else {
    Connector connector=AbstractHttpConnection.getCurrentConnection().getConnector();
    direct=connector instanceof NIOConnector && ((NIOConnector)connector).getUseDirectBuffers() && !(connector instanceof SslConnector);
    content_length=content.getContentLength();
  }
  OutputStream out=null;
  boolean written;
  try {
    out=response.getOutputStream();
    written=out instanceof HttpOutput ? ((HttpOutput)out).isWritten() : AbstractHttpConnection.getCurrentConnection().getGenerator().isWritten();
  }
 catch (  IllegalStateException e) {
    out=new WriterOutputStream(response.getWriter());
    written=true;
  }
  if (reqRanges == null || !reqRanges.hasMoreElements() || content_length < 0) {
    if (include) {
      resource.writeTo(out,0,content_length);
    }
 else {
      if (content != null && !written && out instanceof HttpOutput) {
        if (response instanceof Response) {
          writeOptionHeaders(((Response)response).getHttpFields());
          ((AbstractHttpConnection.Output)out).sendContent(content);
        }
 else {
          Buffer buffer=direct ? content.getDirectBuffer() : content.getIndirectBuffer();
          if (buffer != null) {
            writeHeaders(response,content,content_length);
            ((AbstractHttpConnection.Output)out).sendContent(buffer);
          }
 else {
            writeHeaders(response,content,content_length);
            resource.writeTo(out,0,content_length);
          }
        }
      }
 else {
        writeHeaders(response,content,written ? -1 : content_length);
        Buffer buffer=(content == null) ? null : content.getIndirectBuffer();
        if (buffer != null)         buffer.writeTo(out);
 else         resource.writeTo(out,0,content_length);
      }
    }
  }
 else {
    List ranges=InclusiveByteRange.satisfiableRanges(reqRanges,content_length);
    if (ranges == null || ranges.size() == 0) {
      writeHeaders(response,content,content_length);
      response.setStatus(HttpServletResponse.SC_REQUESTED_RANGE_NOT_SATISFIABLE);
      response.setHeader(HttpHeaders.CONTENT_RANGE,InclusiveByteRange.to416HeaderRangeString(content_length));
      resource.writeTo(out,0,content_length);
      return;
    }
    if (ranges.size() == 1) {
      InclusiveByteRange singleSatisfiableRange=(InclusiveByteRange)ranges.get(0);
      long singleLength=singleSatisfiableRange.getSize(content_length);
      writeHeaders(response,content,singleLength);
      response.setStatus(HttpServletResponse.SC_PARTIAL_CONTENT);
      response.setHeader(HttpHeaders.CONTENT_RANGE,singleSatisfiableRange.toHeaderRangeString(content_length));
      resource.writeTo(out,singleSatisfiableRange.getFirst(content_length),singleLength);
      return;
    }
    writeHeaders(response,content,-1);
    String mimetype=(content.getContentType() == null ? null : content.getContentType().toString());
    if (mimetype == null)     LOG.warn("Unknown mimetype for " + request.getRequestURI());
    MultiPartOutputStream multi=new MultiPartOutputStream(out);
    response.setStatus(HttpServletResponse.SC_PARTIAL_CONTENT);
    String ctp;
    if (request.getHeader(HttpHeaders.REQUEST_RANGE) != null)     ctp="multipart/x-byteranges; boundary=";
 else     ctp="multipart/byteranges; boundary=";
    response.setContentType(ctp + multi.getBoundary());
    InputStream in=resource.getInputStream();
    long pos=0;
    int length=0;
    String[] header=new String[ranges.size()];
    for (int i=0; i < ranges.size(); i++) {
      InclusiveByteRange ibr=(InclusiveByteRange)ranges.get(i);
      header[i]=ibr.toHeaderRangeString(content_length);
      length+=((i > 0) ? 2 : 0) + 2 + multi.getBoundary().length()+ 2+ (mimetype == null ? 0 : HttpHeaders.CONTENT_TYPE.length() + 2 + mimetype.length())+ 2+ HttpHeaders.CONTENT_RANGE.length()+ 2+ header[i].length()+ 2+ 2+ (ibr.getLast(content_length) - ibr.getFirst(content_length))+ 1;
    }
    length+=2 + 2 + multi.getBoundary().length()+ 2+ 2;
    response.setContentLength(length);
    for (int i=0; i < ranges.size(); i++) {
      InclusiveByteRange ibr=(InclusiveByteRange)ranges.get(i);
      multi.startPart(mimetype,new String[]{HttpHeaders.CONTENT_RANGE + ": " + header[i]});
      long start=ibr.getFirst(content_length);
      long size=ibr.getSize(content_length);
      if (in != null) {
        if (start < pos) {
          in.close();
          in=resource.getInputStream();
          pos=0;
        }
        if (pos < start) {
          in.skip(start - pos);
          pos=start;
        }
        IO.copy(in,multi,size);
        pos+=size;
      }
 else       (resource).writeTo(multi,start,size);
    }
    if (in != null)     in.close();
    multi.close();
  }
  return;
}
