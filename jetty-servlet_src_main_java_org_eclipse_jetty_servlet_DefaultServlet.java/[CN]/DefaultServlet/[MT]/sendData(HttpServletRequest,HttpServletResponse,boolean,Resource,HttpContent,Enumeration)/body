{
  boolean direct;
  long content_length;
  if (content == null) {
    direct=false;
    content_length=resource.length();
  }
 else {
    HttpConnector connector=HttpChannel.getCurrentHttpChannel().getHttpConnector();
    direct=!(connector instanceof SslConnector);
    content_length=content.getContentLength();
  }
  OutputStream out=null;
  boolean written;
  try {
    out=response.getOutputStream();
    written=out instanceof HttpOutput ? ((HttpOutput)out).isWritten() : true;
  }
 catch (  IllegalStateException e) {
    out=new WriterOutputStream(response.getWriter());
    written=true;
  }
  if (reqRanges == null || !reqRanges.hasMoreElements() || content_length < 0) {
    if (include) {
      resource.writeTo(out,0,content_length);
    }
 else {
      if (content != null && !written && out instanceof HttpOutput) {
        if (response instanceof Response) {
          writeOptionHeaders(((Response)response).getHttpFields());
          ((HttpOutput)out).sendContent(content);
        }
 else {
          ByteBuffer buffer=direct ? content.getDirectBuffer() : content.getIndirectBuffer();
          if (buffer != null) {
            writeHeaders(response,content,content_length);
            ((HttpOutput)out).sendContent(buffer);
          }
 else {
            writeHeaders(response,content,content_length);
            resource.writeTo(out,0,content_length);
          }
        }
      }
 else {
        writeHeaders(response,content,written ? -1 : content_length);
        ByteBuffer buffer=(content == null) ? null : content.getIndirectBuffer();
        if (buffer != null)         BufferUtil.writeTo(buffer,out);
 else         resource.writeTo(out,0,content_length);
      }
    }
  }
 else {
    List ranges=InclusiveByteRange.satisfiableRanges(reqRanges,content_length);
    if (ranges == null || ranges.size() == 0) {
      writeHeaders(response,content,content_length);
      response.setStatus(HttpServletResponse.SC_REQUESTED_RANGE_NOT_SATISFIABLE);
      response.setHeader(HttpHeader.CONTENT_RANGE.asString(),InclusiveByteRange.to416HeaderRangeString(content_length));
      resource.writeTo(out,0,content_length);
      return;
    }
    if (ranges.size() == 1) {
      InclusiveByteRange singleSatisfiableRange=(InclusiveByteRange)ranges.get(0);
      long singleLength=singleSatisfiableRange.getSize(content_length);
      writeHeaders(response,content,singleLength);
      response.setStatus(HttpServletResponse.SC_PARTIAL_CONTENT);
      response.setHeader(HttpHeader.CONTENT_RANGE.asString(),singleSatisfiableRange.toHeaderRangeString(content_length));
      resource.writeTo(out,singleSatisfiableRange.getFirst(content_length),singleLength);
      return;
    }
    writeHeaders(response,content,-1);
    String mimetype=content.getContentType().toString();
    MultiPartOutputStream multi=new MultiPartOutputStream(out);
    response.setStatus(HttpServletResponse.SC_PARTIAL_CONTENT);
    String ctp;
    if (request.getHeader(HttpHeader.REQUEST_RANGE.asString()) != null)     ctp="multipart/x-byteranges; boundary=";
 else     ctp="multipart/byteranges; boundary=";
    response.setContentType(ctp + multi.getBoundary());
    InputStream in=resource.getInputStream();
    long pos=0;
    int length=0;
    String[] header=new String[ranges.size()];
    for (int i=0; i < ranges.size(); i++) {
      InclusiveByteRange ibr=(InclusiveByteRange)ranges.get(i);
      header[i]=ibr.toHeaderRangeString(content_length);
      length+=((i > 0) ? 2 : 0) + 2 + multi.getBoundary().length()+ 2+ HttpHeader.CONTENT_TYPE.asString().length()+ 2+ mimetype.length()+ 2+ HttpHeader.CONTENT_RANGE.asString().length()+ 2+ header[i].length()+ 2+ 2+ (ibr.getLast(content_length) - ibr.getFirst(content_length))+ 1;
    }
    length+=2 + 2 + multi.getBoundary().length()+ 2+ 2;
    response.setContentLength(length);
    for (int i=0; i < ranges.size(); i++) {
      InclusiveByteRange ibr=(InclusiveByteRange)ranges.get(i);
      multi.startPart(mimetype,new String[]{HttpHeader.CONTENT_RANGE + ": " + header[i]});
      long start=ibr.getFirst(content_length);
      long size=ibr.getSize(content_length);
      if (in != null) {
        if (start < pos) {
          in.close();
          in=resource.getInputStream();
          pos=0;
        }
        if (pos < start) {
          in.skip(start - pos);
          pos=start;
        }
        IO.copy(in,multi,size);
        pos+=size;
      }
 else       (resource).writeTo(multi,start,size);
    }
    if (in != null)     in.close();
    multi.close();
  }
  return;
}
