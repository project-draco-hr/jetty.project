{
  final long content_length=(content == null) ? resource.length() : content.getContentLength();
  OutputStream out=null;
  boolean written;
  try {
    out=response.getOutputStream();
    written=out instanceof HttpOutput ? ((HttpOutput)out).isWritten() : true;
  }
 catch (  IllegalStateException e) {
    out=new WriterOutputStream(response.getWriter());
    written=true;
  }
  if (reqRanges == null || !reqRanges.hasMoreElements() || content_length < 0) {
    if (include) {
      resource.writeTo(out,0,content_length);
    }
 else     if (content == null || written || !(out instanceof HttpOutput)) {
      writeHeaders(response,content,written ? -1 : content_length);
      ByteBuffer buffer=(content == null) ? null : content.getIndirectBuffer();
      if (buffer != null)       BufferUtil.writeTo(buffer,out);
 else       resource.writeTo(out,0,content_length);
    }
 else {
      if (response instanceof Response) {
        Response r=(Response)response;
        writeOptionHeaders(r.getHttpFields());
        r.setHeaders(content);
      }
 else       writeHeaders(response,content,content_length);
      if (request.isAsyncSupported()) {
        final AsyncContext context=request.startAsync();
        ((HttpOutput)out).sendContent(content,new Callback(){
          @Override public void succeeded(){
            context.complete();
          }
          @Override public void failed(          Throwable x){
            LOG.debug(x);
            context.complete();
          }
        }
);
      }
 else {
        ((HttpOutput)out).sendContent(content);
      }
    }
  }
 else {
    List<InclusiveByteRange> ranges=InclusiveByteRange.satisfiableRanges(reqRanges,content_length);
    if (ranges == null || ranges.size() == 0) {
      writeHeaders(response,content,content_length);
      response.setStatus(HttpServletResponse.SC_REQUESTED_RANGE_NOT_SATISFIABLE);
      response.setHeader(HttpHeader.CONTENT_RANGE.asString(),InclusiveByteRange.to416HeaderRangeString(content_length));
      resource.writeTo(out,0,content_length);
      return;
    }
    if (ranges.size() == 1) {
      InclusiveByteRange singleSatisfiableRange=ranges.get(0);
      long singleLength=singleSatisfiableRange.getSize(content_length);
      writeHeaders(response,content,singleLength);
      response.setStatus(HttpServletResponse.SC_PARTIAL_CONTENT);
      response.setHeader(HttpHeader.CONTENT_RANGE.asString(),singleSatisfiableRange.toHeaderRangeString(content_length));
      resource.writeTo(out,singleSatisfiableRange.getFirst(content_length),singleLength);
      return;
    }
    writeHeaders(response,content,-1);
    String mimetype=(content == null ? null : content.getContentType());
    if (mimetype == null)     LOG.warn("Unknown mimetype for " + request.getRequestURI());
    MultiPartOutputStream multi=new MultiPartOutputStream(out);
    response.setStatus(HttpServletResponse.SC_PARTIAL_CONTENT);
    String ctp;
    if (request.getHeader(HttpHeader.REQUEST_RANGE.asString()) != null)     ctp="multipart/x-byteranges; boundary=";
 else     ctp="multipart/byteranges; boundary=";
    response.setContentType(ctp + multi.getBoundary());
    InputStream in=resource.getInputStream();
    long pos=0;
    int length=0;
    String[] header=new String[ranges.size()];
    for (int i=0; i < ranges.size(); i++) {
      InclusiveByteRange ibr=ranges.get(i);
      header[i]=ibr.toHeaderRangeString(content_length);
      length+=((i > 0) ? 2 : 0) + 2 + multi.getBoundary().length()+ 2+ (mimetype == null ? 0 : HttpHeader.CONTENT_TYPE.asString().length() + 2 + mimetype.length())+ 2+ HttpHeader.CONTENT_RANGE.asString().length()+ 2+ header[i].length()+ 2+ 2+ (ibr.getLast(content_length) - ibr.getFirst(content_length))+ 1;
    }
    length+=2 + 2 + multi.getBoundary().length()+ 2+ 2;
    response.setContentLength(length);
    for (int i=0; i < ranges.size(); i++) {
      InclusiveByteRange ibr=ranges.get(i);
      multi.startPart(mimetype,new String[]{HttpHeader.CONTENT_RANGE + ": " + header[i]});
      long start=ibr.getFirst(content_length);
      long size=ibr.getSize(content_length);
      if (in != null) {
        if (start < pos) {
          in.close();
          in=resource.getInputStream();
          pos=0;
        }
        if (pos < start) {
          in.skip(start - pos);
          pos=start;
        }
        IO.copy(in,multi,size);
        pos+=size;
      }
 else       (resource).writeTo(multi,start,size);
    }
    if (in != null)     in.close();
    multi.close();
  }
  return;
}
