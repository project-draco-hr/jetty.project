{
  DispatcherType type=baseRequest.getDispatcherType();
  ServletHolder servlet_holder=(ServletHolder)baseRequest.getUserIdentityScope();
  FilterChain chain=null;
  if (target.startsWith("/")) {
    if (servlet_holder != null && _filterMappings != null && _filterMappings.length > 0)     chain=getFilterChain(baseRequest,target,servlet_holder);
  }
 else {
    if (servlet_holder != null) {
      if (_filterMappings != null && _filterMappings.length > 0) {
        chain=getFilterChain(baseRequest,null,servlet_holder);
      }
    }
  }
  LOG.debug("chain={}",chain);
  try {
    if (servlet_holder == null) {
      notFound(request,response);
    }
 else {
      ServletRequest req=request;
      if (req instanceof ServletRequestHttpWrapper)       req=((ServletRequestHttpWrapper)req).getRequest();
      ServletResponse res=response;
      if (res instanceof ServletResponseHttpWrapper)       res=((ServletResponseHttpWrapper)res).getResponse();
      if (chain != null)       chain.doFilter(req,res);
 else       servlet_holder.handle(baseRequest,req,res);
    }
  }
 catch (  EofException e) {
    throw e;
  }
catch (  UncheckedIOException e) {
    throw e;
  }
catch (  ContinuationThrowable e) {
    throw e;
  }
catch (  Exception e) {
    if (!(DispatcherType.REQUEST.equals(type) || DispatcherType.ASYNC.equals(type))) {
      if (e instanceof IOException)       throw (IOException)e;
      if (e instanceof RuntimeException)       throw (RuntimeException)e;
      if (e instanceof ServletException)       throw (ServletException)e;
    }
    Throwable th=e;
    if (th instanceof UnavailableException) {
      LOG.debug(th);
    }
 else     if (th instanceof ServletException) {
      LOG.debug(th);
      Throwable cause=((ServletException)th).getRootCause();
      if (cause != null)       th=cause;
    }
 else     if (th instanceof UncheckedIOException) {
      LOG.debug(th);
      Throwable cause=(IOException)((UncheckedIOException)th).getCause();
      if (cause != null)       th=cause;
    }
    if (th instanceof HttpException)     throw (HttpException)th;
 else     if (th instanceof UncheckedIOException)     throw (UncheckedIOException)th;
 else     if (th instanceof EofException)     throw (EofException)th;
 else     if (LOG.isDebugEnabled()) {
      LOG.warn(request.getRequestURI(),th);
      LOG.debug(request.toString());
    }
 else     if (th instanceof IOException || th instanceof UnavailableException) {
      LOG.debug(request.getRequestURI(),th);
    }
 else {
      LOG.warn(request.getRequestURI(),th);
    }
    if (!response.isCommitted()) {
      request.setAttribute(Dispatcher.ERROR_EXCEPTION_TYPE,th.getClass());
      request.setAttribute(Dispatcher.ERROR_EXCEPTION,th);
      if (th instanceof UnavailableException) {
        UnavailableException ue=(UnavailableException)th;
        if (ue.isPermanent())         response.sendError(HttpServletResponse.SC_NOT_FOUND,th.getMessage());
 else         response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,th.getMessage());
      }
 else       response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,th.getMessage());
    }
 else     LOG.debug("Response already committed for handling " + th);
  }
catch (  Error e) {
    if (!(DispatcherType.REQUEST.equals(type) || DispatcherType.ASYNC.equals(type)))     throw e;
    LOG.warn("Error for " + request.getRequestURI(),e);
    if (LOG.isDebugEnabled())     LOG.debug(request.toString());
    if (!response.isCommitted()) {
      request.setAttribute(Dispatcher.ERROR_EXCEPTION_TYPE,e.getClass());
      request.setAttribute(Dispatcher.ERROR_EXCEPTION,e);
      response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,e.getMessage());
    }
 else     LOG.debug("Response already committed for handling ",e);
  }
 finally {
    baseRequest.setHandled(true);
  }
}
