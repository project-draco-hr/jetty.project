{
  StandardSession.FrameBytes frameBytes=null;
synchronized (lock) {
    if (active.size() > 0)     throw new IllegalStateException();
    if (queue.isEmpty())     return State.IDLE;
    int qs=queue.size();
    for (int i=0; i < qs && active.size() < MAX_GATHER; ) {
      frameBytes=queue.getUnsafe(i);
      IStream stream=frameBytes.getStream();
      if (stream != null) {
        if (stalled.size() > 0 && stalled.contains(stream)) {
          i++;
          continue;
        }
        if (stream.getWindowSize() <= 0) {
          stalled.add(stream);
          i++;
          continue;
        }
      }
      queue.remove(i);
      qs--;
      if (stream != null && stream.isReset() && !(frameBytes instanceof StandardSession.ControlFrameBytes)) {
        frameBytes.failed(new StreamException(frameBytes.getStream().getId(),StreamStatus.INVALID_STREAM,"Stream: " + frameBytes.getStream() + " is reset!"));
        continue;
      }
      active.add(frameBytes);
    }
    stalled.clear();
    if (LOG.isDebugEnabled())     LOG.debug("Flushing {} of {} frame(s) in queue",active.size(),queue.size());
  }
  if (active.size() == 0)   return State.IDLE;
  ByteBuffer[] buffers=new ByteBuffer[active.size()];
  for (int i=0; i < buffers.length; i++)   buffers[i]=active.get(i).getByteBuffer();
  if (controller != null)   controller.write(iteratingCallback,buffers);
  return State.SCHEDULED;
}
