{
synchronized (lock) {
    succeeded.clear();
    int qs=queue.size();
    for (int i=0; i < qs && active.size() < MAX_GATHER; ) {
      StandardSession.FrameBytes frameBytes=queue.getUnsafe(i);
      IStream stream=frameBytes.getStream();
      if (stream != null) {
        if (stalled.size() > 0 && stalled.contains(stream)) {
          i++;
          continue;
        }
        if (stream.getWindowSize() <= 0) {
          stalled.add(stream);
          i++;
          continue;
        }
      }
      queue.remove(i);
      qs--;
      if (stream != null && stream.isReset() && !(frameBytes instanceof StandardSession.ControlFrameBytes)) {
        frameBytes.failed(new StreamException(frameBytes.getStream().getId(),StreamStatus.INVALID_STREAM,"Stream: " + frameBytes.getStream() + " is reset!"));
        continue;
      }
      active.add(frameBytes);
    }
    stalled.clear();
    if (LOG.isDebugEnabled())     LOG.debug("Flushing {} of {} frame(s) in queue",active.size(),queue.size());
  }
  if (active.size() == 0)   return Next.IDLE;
  ByteBuffer[] buffers=new ByteBuffer[active.size()];
  for (int i=0; i < buffers.length; i++)   buffers[i]=active.get(i).getByteBuffer();
  if (controller != null)   controller.write(flusherCB,buffers);
  return Next.SCHEDULED;
}
