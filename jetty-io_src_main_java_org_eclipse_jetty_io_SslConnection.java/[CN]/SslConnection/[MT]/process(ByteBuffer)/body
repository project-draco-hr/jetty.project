{
  boolean some_progress=false;
  _lock.lock();
  try {
    allocateBuffers();
    if (appOut == null)     appOut=__ZERO_BUFFER;
    boolean progress=true;
    while (progress) {
      progress=false;
switch (_engine.getHandshakeStatus()) {
case FINISHED:
        throw new IllegalStateException();
case NOT_HANDSHAKING:
{
        if (!BufferUtil.isFull(_inApp) && BufferUtil.hasContent(_inNet) && unwrap())         progress=true;
        if (BufferUtil.hasContent(appOut) && !BufferUtil.isFull(_outNet) && wrap(appOut))         progress=true;
      }
    break;
case NEED_TASK:
{
    Runnable task;
    while ((task=_engine.getDelegatedTask()) != null) {
      progress=true;
      task.run();
    }
  }
break;
case NEED_WRAP:
{
if (_handshook && !_allowRenegotiate) _endp.close();
 else if (wrap(appOut)) progress=true;
}
break;
case NEED_UNWRAP:
{
if (_handshook && !_allowRenegotiate) _endp.close();
 else if (BufferUtil.isEmpty(_inNet) && _endp.isInputShutdown()) _endp.close();
 else if (unwrap()) progress=true;
}
break;
}
if (_endp.isOpen() && _endp.isInputShutdown() && BufferUtil.isEmpty(_inNet)) _engine.closeInbound();
if (_endp.isOpen() && _engine.isOutboundDone() && BufferUtil.isEmpty(_outNet)) _endp.shutdownOutput();
some_progress|=progress;
}
}
 catch (SSLException e) {
LOG.warn(e.toString());
LOG.debug(e);
_endp.close();
}
 finally {
releaseBuffers();
_lock.unlock();
}
return some_progress;
}
