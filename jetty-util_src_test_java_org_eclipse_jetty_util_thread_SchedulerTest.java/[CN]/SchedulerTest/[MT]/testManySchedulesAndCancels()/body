{
  final Random random=new Random();
  Thread[] test=new Thread[500];
  final AtomicInteger schedules=new AtomicInteger();
  final SampleStatistic executions=new SampleStatistic();
  final SampleStatistic cancellations=new SampleStatistic();
  for (int i=test.length; i-- > 0; ) {
    test[i]=new Thread(){
      @Override public void run(){
        try {
          long now=System.currentTimeMillis();
          long start=now;
          long end=start + 5000;
          while (now < end) {
            final int delay=random.nextInt((int)(end - now));
            final long expected=now + delay;
            int cancel=random.nextInt(200);
            if (cancel == 0)             cancel=(int)(end - now) + 1000;
 else             cancel=cancel / 4;
            schedules.incrementAndGet();
            Scheduler.Task task=_scheduler.schedule(new Runnable(){
              @Override public void run(){
                long lateness=System.currentTimeMillis() - expected;
                executions.set(lateness);
              }
            }
,delay,TimeUnit.MILLISECONDS);
            Thread.sleep(cancel);
            now=System.currentTimeMillis();
            if (task.cancel()) {
              long lateness=now - expected;
              cancellations.set(lateness);
            }
          }
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
      }
    }
;
  }
  for (  Thread thread : test)   thread.start();
  for (  Thread thread : test)   thread.join();
  Assert.assertThat(executions.getCount(),Matchers.greaterThan(0L));
  Assert.assertThat(cancellations.getCount(),Matchers.greaterThan(0L));
  Assert.assertThat(0L + schedules.get(),Matchers.lessThanOrEqualTo(executions.getCount() + cancellations.getCount()));
  Assert.assertThat(executions.getMax(),Matchers.lessThan(500L));
  Assert.assertThat(executions.getMean(),Matchers.lessThan(500.0));
  Assert.assertThat(cancellations.getMax(),Matchers.lessThan(500L));
}
