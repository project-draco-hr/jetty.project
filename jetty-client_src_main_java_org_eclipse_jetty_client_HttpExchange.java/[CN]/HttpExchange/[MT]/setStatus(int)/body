{
  try {
    int oldStatus=_status.get();
    boolean set=false;
    if (oldStatus != newStatus) {
      long now=System.currentTimeMillis();
      _lastStatePeriod=(int)(now - _lastStateChange);
      _lastState=oldStatus;
      _lastStateChange=now;
      if (newStatus == STATUS_SENDING_REQUEST)       _sent=_lastStateChange;
    }
switch (oldStatus) {
case STATUS_START:
switch (newStatus) {
case STATUS_START:
case STATUS_WAITING_FOR_CONNECTION:
case STATUS_WAITING_FOR_COMMIT:
case STATUS_CANCELLING:
case STATUS_EXCEPTED:
        set=_status.compareAndSet(oldStatus,newStatus);
      break;
case STATUS_EXPIRED:
    set=setStatusExpired(newStatus,oldStatus);
  break;
}
break;
case STATUS_WAITING_FOR_CONNECTION:
switch (newStatus) {
case STATUS_WAITING_FOR_COMMIT:
case STATUS_CANCELLING:
case STATUS_EXCEPTED:
set=_status.compareAndSet(oldStatus,newStatus);
break;
case STATUS_EXPIRED:
set=setStatusExpired(newStatus,oldStatus);
break;
}
break;
case STATUS_WAITING_FOR_COMMIT:
switch (newStatus) {
case STATUS_SENDING_REQUEST:
case STATUS_CANCELLING:
case STATUS_EXCEPTED:
set=_status.compareAndSet(oldStatus,newStatus);
break;
case STATUS_EXPIRED:
set=setStatusExpired(newStatus,oldStatus);
break;
}
break;
case STATUS_SENDING_REQUEST:
switch (newStatus) {
case STATUS_WAITING_FOR_RESPONSE:
if (set=_status.compareAndSet(oldStatus,newStatus)) getEventListener().onRequestCommitted();
break;
case STATUS_CANCELLING:
case STATUS_EXCEPTED:
set=_status.compareAndSet(oldStatus,newStatus);
break;
case STATUS_EXPIRED:
set=setStatusExpired(newStatus,oldStatus);
break;
}
break;
case STATUS_WAITING_FOR_RESPONSE:
switch (newStatus) {
case STATUS_PARSING_HEADERS:
case STATUS_CANCELLING:
case STATUS_EXCEPTED:
set=_status.compareAndSet(oldStatus,newStatus);
break;
case STATUS_EXPIRED:
set=setStatusExpired(newStatus,oldStatus);
break;
}
break;
case STATUS_PARSING_HEADERS:
switch (newStatus) {
case STATUS_PARSING_CONTENT:
if (set=_status.compareAndSet(oldStatus,newStatus)) getEventListener().onResponseHeaderComplete();
break;
case STATUS_CANCELLING:
case STATUS_EXCEPTED:
set=_status.compareAndSet(oldStatus,newStatus);
break;
case STATUS_EXPIRED:
set=setStatusExpired(newStatus,oldStatus);
break;
}
break;
case STATUS_PARSING_CONTENT:
switch (newStatus) {
case STATUS_COMPLETED:
if (set=_status.compareAndSet(oldStatus,newStatus)) getEventListener().onResponseComplete();
break;
case STATUS_CANCELLING:
case STATUS_EXCEPTED:
set=_status.compareAndSet(oldStatus,newStatus);
break;
case STATUS_EXPIRED:
set=setStatusExpired(newStatus,oldStatus);
break;
}
break;
case STATUS_COMPLETED:
switch (newStatus) {
case STATUS_START:
case STATUS_EXCEPTED:
case STATUS_WAITING_FOR_RESPONSE:
set=_status.compareAndSet(oldStatus,newStatus);
break;
case STATUS_CANCELLING:
case STATUS_EXPIRED:
set=true;
break;
}
break;
case STATUS_CANCELLING:
switch (newStatus) {
case STATUS_EXCEPTED:
case STATUS_CANCELLED:
if (set=_status.compareAndSet(oldStatus,newStatus)) done();
break;
default :
set=true;
break;
}
break;
case STATUS_EXCEPTED:
case STATUS_EXPIRED:
case STATUS_CANCELLED:
switch (newStatus) {
case STATUS_START:
set=_status.compareAndSet(oldStatus,newStatus);
break;
case STATUS_COMPLETED:
set=true;
done();
break;
default :
set=true;
break;
}
break;
default :
throw new AssertionError(oldStatus + " => " + newStatus);
}
if (!set) throw new IllegalStateException(toState(oldStatus) + " => " + toState(newStatus));
}
 catch (IOException x) {
LOG.warn(x);
}
}
