{
  final ConcurrentArrayBlockingQueue<Integer> queue=newConcurrentArrayQueue(512);
  int readerCount=16;
  final int factor=2;
  int writerCount=readerCount * factor;
  final int iterations=4096;
  for (int runs=0; runs < 16; ++runs) {
    ExecutorService executor=Executors.newFixedThreadPool(readerCount + writerCount);
    List<Future<Integer>> readers=new ArrayList<>();
    for (int i=0; i < readerCount / 2; ++i) {
      final int reader=i;
      readers.add(executor.submit(new Callable<Integer>(){
        @Override public Integer call() throws Exception {
          int sum=0;
          for (int j=0; j < iterations * factor; ++j)           sum+=queue.take();
          return sum;
        }
      }
));
      readers.add(executor.submit(new Callable<Integer>(){
        @Override public Integer call() throws Exception {
          int sum=0;
          for (int j=0; j < iterations * factor; ++j)           sum+=queue.poll(5,TimeUnit.SECONDS);
          return sum;
        }
      }
));
    }
    for (int i=0; i < writerCount; ++i) {
      final int writer=i;
      executor.submit(new Callable<Object>(){
        @Override public Object call() throws Exception {
          for (int j=0; j < iterations; ++j)           queue.offer(1);
          return null;
        }
      }
);
    }
    int sum=0;
    for (    Future<Integer> result : readers)     sum+=result.get();
    Assert.assertEquals(writerCount * iterations,sum);
    Assert.assertTrue(queue.isEmpty());
  }
}
