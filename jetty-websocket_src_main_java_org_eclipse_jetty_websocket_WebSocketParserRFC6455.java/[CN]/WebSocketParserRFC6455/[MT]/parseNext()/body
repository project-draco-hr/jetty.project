{
  if (_buffer == null)   _buffer=_buffers.getBuffer();
  boolean progress=false;
  int filled=-1;
  while (!progress && (!_endp.isInputShutdown() || _buffer.length() > 0)) {
    int available=_buffer.length();
    while (available < (_state == State.SKIP ? 1 : _bytesNeeded)) {
      _buffer.compact();
      if (_buffer.space() == 0) {
        if (_fragmentFrames && _state == State.DATA) {
          ByteBuffer data=_buffer.get(4 * (available / 4));
          _buffer.compact();
          if (_masked) {
            if (data.array() == null)             data=_buffer.asMutableBuffer();
            byte[] array=data.array();
            final int end=data.putIndex();
            for (int i=data.getIndex(); i < end; i++)             array[i]^=_mask[_m++ % 4];
          }
          _bytesNeeded-=data.length();
          progress=true;
          _handler.onFrame((byte)(_flags & (0xff ^ WebSocketConnectionRFC6455.FLAG_FIN)),_opcode,data);
          _opcode=WebSocketConnectionRFC6455.OP_CONTINUATION;
        }
        if (_buffer.space() == 0)         throw new IllegalStateException("FULL: " + _state + " "+ _bytesNeeded+ ">"+ _buffer.capacity());
      }
      try {
        filled=_endp.isInputShutdown() ? -1 : _endp.fill(_buffer);
        available=_buffer.length();
        if (filled <= 0)         break;
      }
 catch (      IOException e) {
        LOG.debug(e);
        filled=-1;
        break;
      }
    }
    if (available < (_state == State.SKIP ? 1 : _bytesNeeded))     break;
    byte b;
    while (_state != State.DATA && available >= (_state == State.SKIP ? 1 : _bytesNeeded)) {
switch (_state) {
case START:
        _skip=false;
      _state=_opcode == WebSocketConnectionRFC6455.OP_CLOSE ? State.SEEK_EOF : State.OPCODE;
    _bytesNeeded=_state.getNeeds();
  continue;
case OPCODE:
b=_buffer.get();
available--;
_opcode=(byte)(b & 0xf);
_flags=(byte)(0xf & (b >> 4));
if (WebSocketConnectionRFC6455.isControlFrame(_opcode) && !WebSocketConnectionRFC6455.isLastFrame(_flags)) {
LOG.warn("Fragmented Control from " + _endp);
_handler.close(WebSocketConnectionRFC6455.CLOSE_PROTOCOL,"Fragmented control");
progress=true;
_skip=true;
}
_state=State.LENGTH_7;
_bytesNeeded=_state.getNeeds();
continue;
case LENGTH_7:
b=_buffer.get();
available--;
_masked=(b & 0x80) != 0;
b=(byte)(0x7f & b);
switch (b) {
case 0x7f:
_length=0;
_state=State.LENGTH_63;
break;
case 0x7e:
_length=0;
_state=State.LENGTH_16;
break;
default :
_length=(0x7f & b);
_state=_masked ? State.MASK : State.PAYLOAD;
}
_bytesNeeded=_state.getNeeds();
continue;
case LENGTH_16:
b=_buffer.get();
available--;
_length=_length * 0x100 + (0xff & b);
if (--_bytesNeeded == 0) {
if (_length > _buffer.capacity() && !_fragmentFrames) {
progress=true;
_handler.close(WebSocketConnectionRFC6455.CLOSE_POLICY_VIOLATION,"frame size " + _length + ">"+ _buffer.capacity());
_skip=true;
}
_state=_masked ? State.MASK : State.PAYLOAD;
_bytesNeeded=_state.getNeeds();
}
continue;
case LENGTH_63:
b=_buffer.get();
available--;
_length=_length * 0x100 + (0xff & b);
if (--_bytesNeeded == 0) {
_bytesNeeded=(int)_length;
if (_length >= _buffer.capacity() && !_fragmentFrames) {
progress=true;
_handler.close(WebSocketConnectionRFC6455.CLOSE_POLICY_VIOLATION,"frame size " + _length + ">"+ _buffer.capacity());
_skip=true;
}
_state=_masked ? State.MASK : State.PAYLOAD;
_bytesNeeded=_state.getNeeds();
}
continue;
case MASK:
_buffer.get(_mask,0,4);
_m=0;
available-=4;
_state=State.PAYLOAD;
_bytesNeeded=_state.getNeeds();
break;
case PAYLOAD:
_bytesNeeded=(int)_length;
_state=_skip ? State.SKIP : State.DATA;
break;
case DATA:
break;
case SKIP:
int skip=Math.min(available,_bytesNeeded);
progress=true;
_buffer.skip(skip);
available-=skip;
_bytesNeeded-=skip;
if (_bytesNeeded == 0) _state=State.START;
break;
case SEEK_EOF:
progress=true;
_buffer.skip(available);
available=0;
break;
}
}
if (_state == State.DATA && available >= _bytesNeeded) {
if (_masked != _shouldBeMasked) {
_buffer.skip(_bytesNeeded);
_state=State.START;
progress=true;
_handler.close(WebSocketConnectionRFC6455.CLOSE_PROTOCOL,"Not masked");
}
 else {
ByteBuffer data=_buffer.get(_bytesNeeded);
if (_masked) {
if (data.array() == null) data=_buffer.asMutableBuffer();
byte[] array=data.array();
final int end=data.putIndex();
for (int i=data.getIndex(); i < end; i++) array[i]^=_mask[_m++ % 4];
}
progress=true;
_handler.onFrame(_flags,_opcode,data);
_bytesNeeded=0;
_state=State.START;
}
break;
}
}
return progress ? 1 : filled;
}
