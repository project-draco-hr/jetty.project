{
  ByteBuffer bbuf=extractByteBuffer(buffer);
  final SSLEngineResult result;
synchronized (bbuf) {
    _outbound.compact();
    ByteBuffer out_buffer=_outbound.getByteBuffer();
synchronized (out_buffer) {
      try {
        bbuf.position(buffer.getIndex());
        bbuf.limit(buffer.putIndex());
        out_buffer.position(_outbound.putIndex());
        out_buffer.limit(out_buffer.capacity());
        result=_engine.wrap(bbuf,out_buffer);
        if (LOG.isDebugEnabled())         LOG.debug("{} wrap {} {} consumed={} produced={}",_session,result.getStatus(),result.getHandshakeStatus(),result.bytesConsumed(),result.bytesProduced());
        buffer.skip(result.bytesConsumed());
        _outbound.setPutIndex(_outbound.putIndex() + result.bytesProduced());
      }
 catch (      SSLException e) {
        LOG.warn(_endp + ":",e);
        _endp.close();
        throw e;
      }
 finally {
        out_buffer.position(0);
        out_buffer.limit(out_buffer.capacity());
        bbuf.position(0);
        bbuf.limit(bbuf.capacity());
      }
    }
  }
switch (result.getStatus()) {
case BUFFER_UNDERFLOW:
    throw new IllegalStateException();
case BUFFER_OVERFLOW:
  break;
case OK:
if (result.getHandshakeStatus() == HandshakeStatus.FINISHED) _handshook=true;
break;
case CLOSED:
_endp.close();
break;
default :
LOG.warn("{} wrap default {}",_session,result);
throw new IOException(result.toString());
}
return result.bytesConsumed() > 0 || result.bytesProduced() > 0;
}
