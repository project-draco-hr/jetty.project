{
  boolean some_progress=false;
  try {
    allocateBuffers();
    if (toFill == null) {
      _unwrapBuf.compact().flip();
      toFill=_unwrapBuf;
    }
 else     if (toFill.capacity() < _session.getApplicationBufferSize()) {
      boolean progress=process(null,toFlush);
      if (BufferUtil.hasContent(_unwrapBuf)) {
        BufferUtil.flipPutFlip(_unwrapBuf,toFill);
        return true;
      }
 else       return progress;
    }
 else     if (BufferUtil.hasContent(_unwrapBuf)) {
      BufferUtil.flipPutFlip(_unwrapBuf,toFill);
      return true;
    }
    if (toFlush == null)     toFlush=__ZERO_BUFFER;
    boolean progress=true;
    while (progress) {
      progress=false;
      int filled=0, flushed=0;
      try {
        if (!BufferUtil.isFull(_inbound) && (filled=_endp.fill(_inbound)) > 0)         progress=true;
 else         _inbound.compact().flip();
        if (BufferUtil.hasContent(_outbound) && (flushed=_endp.flush(_outbound)) > 0) {
          progress=true;
          _outbound.compact().flip();
        }
      }
 catch (      IOException e) {
        _endp.close();
        throw e;
      }
 finally {
        _logger.debug("{} {} {} filled={}/{} flushed={}/{}",_session,this,_engine.getHandshakeStatus(),filled,_inbound.remaining(),flushed,_outbound.remaining());
      }
switch (_engine.getHandshakeStatus()) {
case FINISHED:
        throw new IllegalStateException();
case NOT_HANDSHAKING:
{
        if (!BufferUtil.isFull(toFill) && BufferUtil.hasContent(_inbound) && unwrap(toFill))         progress=true;
        if (BufferUtil.hasContent(toFlush) && !BufferUtil.isFull(_outbound) && wrap(toFlush))         progress=true;
      }
    break;
case NEED_TASK:
{
    Runnable task;
    while ((task=_engine.getDelegatedTask()) != null) {
      progress=true;
      task.run();
    }
  }
break;
case NEED_WRAP:
{
if (_handshook && !_allowRenegotiate) _endp.close();
 else if (wrap(toFlush)) progress=true;
}
break;
case NEED_UNWRAP:
{
if (_handshook && !_allowRenegotiate) _endp.close();
 else if (BufferUtil.isEmpty(_inbound) && filled == -1) {
_endp.shutdownInput();
}
 else if (unwrap(toFill)) progress=true;
}
break;
}
if (_endp.isOpen() && _endp.isInputShutdown() && BufferUtil.isEmpty(_inbound)) _engine.closeInbound();
if (_endp.isOpen() && _engine.isOutboundDone() && BufferUtil.isEmpty(_outbound)) _endp.shutdownOutput();
some_progress|=progress;
}
if (toFill == _unwrapBuf && BufferUtil.hasContent(_unwrapBuf)) _aEndp.asyncDispatch();
}
  finally {
releaseBuffers();
if (some_progress) _progressed.set(true);
}
return some_progress;
}
