{
  if (toFill == null) {
    if (_unwrapBuf == null)     _unwrapBuf=new IndirectNIOBuffer(_session.getApplicationBufferSize() * 2);
    toFill=_unwrapBuf;
  }
 else   if (toFill.capacity() < _session.getApplicationBufferSize()) {
    boolean progress=process(null,toFlush);
    if (_unwrapBuf != null && _unwrapBuf.hasContent()) {
      _unwrapBuf.skip(toFill.put(_unwrapBuf));
      return true;
    }
 else     return progress;
  }
 else   if (_unwrapBuf != null && _unwrapBuf.hasContent()) {
    _unwrapBuf.skip(toFill.put(_unwrapBuf));
    return true;
  }
  if (toFlush == null)   toFlush=__ZERO_BUFFER;
  boolean progress=true;
  boolean some_progress=false;
  try {
    allocateBuffers();
    while (progress) {
      progress=false;
      int filled=0, flushed=0;
      try {
        if (_inbound.space() > 0 && (filled=_endp.fill(_inbound)) > 0)         progress=true;
        if (_outbound.hasContent() && (flushed=_endp.flush(_outbound)) > 0)         progress=true;
      }
 catch (      Exception e) {
        LOG.debug(e.toString());
        LOG.ignore(e);
      }
      LOG.debug("{} {} filled={}/{} flushed={}/{}",_session,this,filled,_inbound.length(),flushed,_outbound.length());
      LOG.debug("{} status {}",_session,_engine.getHandshakeStatus());
switch (_engine.getHandshakeStatus()) {
case FINISHED:
        throw new IllegalStateException();
case NOT_HANDSHAKING:
{
        if (toFlush.hasContent() && _outbound.space() > 0 && wrap(toFlush))         progress=true;
        if (toFill.space() > 0 && _inbound.hasContent() && unwrap(toFill))         progress=true;
      }
    break;
case NEED_TASK:
{
    Runnable task;
    while ((task=_engine.getDelegatedTask()) != null) {
      progress=true;
      task.run();
    }
  }
break;
case NEED_WRAP:
{
if (_handshook && !_allowRenegotiate) _endp.close();
 else if (wrap(toFlush)) progress=true;
}
break;
case NEED_UNWRAP:
{
if (_handshook && !_allowRenegotiate) _endp.close();
 else if (unwrap(toFill)) progress=true;
}
break;
}
if (!_inbound.hasContent() && _endp.isInputShutdown()) _engine.closeInbound();
if (!_outbound.hasContent() && _engine.isOutboundDone()) _endp.shutdownOutput();
LOG.debug("{} process progress={}",_session,progress);
some_progress|=progress;
}
}
  finally {
releaseBuffers();
}
return some_progress;
}
