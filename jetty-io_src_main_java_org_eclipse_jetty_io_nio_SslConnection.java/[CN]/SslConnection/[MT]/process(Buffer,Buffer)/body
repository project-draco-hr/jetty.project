{
  boolean some_progress=false;
  try {
    allocateBuffers();
    if (toFill == null) {
      _unwrapBuf.compact();
      toFill=_unwrapBuf;
    }
 else     if (toFill.capacity() < _session.getApplicationBufferSize()) {
      boolean progress=process(null,toFlush);
      if (_unwrapBuf != null && _unwrapBuf.hasContent()) {
        _unwrapBuf.skip(toFill.put(_unwrapBuf));
        return true;
      }
 else       return progress;
    }
 else     if (_unwrapBuf != null && _unwrapBuf.hasContent()) {
      _unwrapBuf.skip(toFill.put(_unwrapBuf));
      return true;
    }
    if (toFlush == null)     toFlush=__ZERO_BUFFER;
    boolean progress=true;
    while (progress) {
      progress=false;
      int filled=0, flushed=0;
      try {
        if (_inbound.space() > 0 && (filled=_endp.fill(_inbound)) > 0)         progress=true;
        if (_outbound.hasContent() && (flushed=_endp.flush(_outbound)) > 0)         progress=true;
      }
 catch (      IOException e) {
        _endp.close();
        throw e;
      }
 finally {
        _logger.debug("{} {} {} filled={}/{} flushed={}/{}",_session,this,_engine.getHandshakeStatus(),filled,_inbound.length(),flushed,_outbound.length());
      }
switch (_engine.getHandshakeStatus()) {
case FINISHED:
        throw new IllegalStateException();
case NOT_HANDSHAKING:
{
        if (toFill.space() > 0 && _inbound.hasContent() && unwrap(toFill))         progress=true;
        if (toFlush.hasContent() && _outbound.space() > 0 && wrap(toFlush))         progress=true;
      }
    break;
case NEED_TASK:
{
    Runnable task;
    while ((task=_engine.getDelegatedTask()) != null) {
      progress=true;
      task.run();
    }
  }
break;
case NEED_WRAP:
{
if (_handshook && !_allowRenegotiate) _endp.close();
 else if (wrap(toFlush)) progress=true;
}
break;
case NEED_UNWRAP:
{
if (_handshook && !_allowRenegotiate) _endp.close();
 else if (!_inbound.hasContent() && filled == -1) {
_endp.shutdownInput();
}
 else if (unwrap(toFill)) progress=true;
}
break;
}
if (_endp.isOpen() && _endp.isInputShutdown() && !_inbound.hasContent()) closeInbound();
if (_endp.isOpen() && _engine.isOutboundDone() && !_outbound.hasContent()) _endp.shutdownOutput();
some_progress|=progress;
}
if (toFill == _unwrapBuf && _unwrapBuf.hasContent() && !_connection.isSuspended()) _aEndp.dispatch();
}
  finally {
releaseBuffers();
if (some_progress) _progressed.set(true);
}
return some_progress;
}
