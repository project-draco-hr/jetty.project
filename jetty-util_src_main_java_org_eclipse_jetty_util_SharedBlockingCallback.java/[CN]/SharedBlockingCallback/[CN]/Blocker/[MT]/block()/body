{
  if (NonBlockingThread.isNonBlockingThread())   LOG.warn("Blocking a NonBlockingThread: ",new Throwable());
  _lock.lock();
  long idle=getIdleTimeout();
  try {
    while (_state == null) {
      if (idle > 0 && (idle < Long.MAX_VALUE / 2)) {
        if (!_complete.await(idle + idle / 2,TimeUnit.MILLISECONDS))         _state=new BlockerTimeoutException();
      }
 else       _complete.await();
    }
    if (_state == SUCCEEDED)     return;
    if (_state == IDLE)     throw new IllegalStateException("IDLE");
    if (_state instanceof IOException)     throw (IOException)_state;
    if (_state instanceof CancellationException)     throw (CancellationException)_state;
    if (_state instanceof RuntimeException)     throw (RuntimeException)_state;
    if (_state instanceof Error)     throw (Error)_state;
    throw new IOException(_state);
  }
 catch (  final InterruptedException e) {
    throw new InterruptedIOException();
  }
 finally {
    _lock.unlock();
  }
}
