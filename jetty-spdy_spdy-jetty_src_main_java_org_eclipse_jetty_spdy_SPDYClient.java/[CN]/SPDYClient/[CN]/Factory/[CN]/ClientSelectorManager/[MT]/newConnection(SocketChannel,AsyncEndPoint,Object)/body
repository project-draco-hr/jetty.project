{
  SessionPromise sessionPromise=(SessionPromise)attachment;
  final SPDYClient client=sessionPromise.client;
  try {
    if (sslContextFactory != null) {
      SSLEngine engine=client.newSSLEngine(sslContextFactory,channel);
      SslConnection sslConnection=new SslConnection(engine,endPoint);
      endPoint.setConnection(sslConnection);
      final AsyncEndPoint sslEndPoint=sslConnection.getSslEndPoint();
      NextProtoNego.put(engine,new NextProtoNego.ClientProvider(){
        @Override public boolean supports(){
          return true;
        }
        @Override public void unsupported(){
          ClientSPDYAsyncConnectionFactory connectionFactory=new ClientSPDYAsyncConnectionFactory();
          AsyncConnection connection=connectionFactory.newAsyncConnection(channel,sslEndPoint,attachment);
          sslEndPoint.setConnection(connection);
        }
        @Override public String selectProtocol(        List<String> protocols){
          String protocol=client.selectProtocol(protocols);
          if (protocol == null)           return null;
          AsyncConnectionFactory connectionFactory=client.getAsyncConnectionFactory(protocol);
          AsyncConnection connection=connectionFactory.newAsyncConnection(channel,sslEndPoint,attachment);
          sslEndPoint.setConnection(connection);
          return protocol;
        }
      }
);
      AsyncConnection connection=new EmptyAsyncConnection(sslEndPoint);
      sslEndPoint.setConnection(connection);
      startHandshake(engine);
      return sslConnection;
    }
 else {
      AsyncConnectionFactory connectionFactory=new ClientSPDYAsyncConnectionFactory();
      AsyncConnection connection=connectionFactory.newAsyncConnection(channel,endPoint,attachment);
      endPoint.setConnection(connection);
      return connection;
    }
  }
 catch (  RuntimeException x) {
    sessionPromise.failed(x);
    throw x;
  }
}
