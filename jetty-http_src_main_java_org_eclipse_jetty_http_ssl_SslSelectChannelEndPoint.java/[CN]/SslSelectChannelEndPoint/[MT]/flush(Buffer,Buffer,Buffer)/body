{
  int consumed=0;
  int available=header.length();
  if (buffer != null)   available+=buffer.length();
  int tries=0;
  loop:   while (true) {
    if (tries++ > 100)     throw new IllegalStateException();
    if (_outNIOBuffer.length() > 0)     flush();
switch (_engine.getHandshakeStatus()) {
case FINISHED:
case NOT_HANDSHAKING:
      if (_closing || available == 0) {
        if (consumed == 0)         consumed=-1;
        break loop;
      }
    int c=(header != null && buffer != null) ? wrap(header,buffer) : wrap(header);
  if (c > 0) {
    consumed+=c;
    available-=c;
  }
 else   if (c < 0) {
    if (consumed == 0)     consumed=-1;
    break loop;
  }
break;
case NEED_UNWRAP:
Buffer buf=_buffers.getBuffer(_engine.getSession().getApplicationBufferSize());
try {
ByteBuffer bbuf=((NIOBuffer)buf).getByteBuffer();
if (!unwrap(bbuf) && _engine.getHandshakeStatus() == HandshakeStatus.NEED_UNWRAP) {
break loop;
}
}
  finally {
_buffers.returnBuffer(buf);
}
break;
case NEED_TASK:
{
Runnable task;
while ((task=_engine.getDelegatedTask()) != null) {
task.run();
}
break;
}
case NEED_WRAP:
{
synchronized (_outBuffer) {
try {
_outNIOBuffer.compact();
int put=_outNIOBuffer.putIndex();
_outBuffer.position();
_result=null;
_last="flush wrap";
_result=_engine.wrap(__NO_BUFFERS,_outBuffer);
switch (_result.getStatus()) {
case BUFFER_OVERFLOW:
case BUFFER_UNDERFLOW:
Log.warn("unwrap {}",_result);
case CLOSED:
_closing=true;
}
_outNIOBuffer.setPutIndex(put + _result.bytesProduced());
}
  finally {
_outBuffer.position(0);
}
}
flush();
break;
}
}
}
return consumed;
}
