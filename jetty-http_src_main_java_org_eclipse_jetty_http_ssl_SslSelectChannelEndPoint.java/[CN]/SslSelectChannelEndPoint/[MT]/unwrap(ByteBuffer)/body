{
  if (_inNIOBuffer.hasContent())   _inNIOBuffer.compact();
 else   _inNIOBuffer.clear();
  int total_filled=0;
  while (_inNIOBuffer.space() > 0 && super.isOpen()) {
    try {
      int filled=super.fill(_inNIOBuffer);
      if (_debug)       __log.debug(_session + " unwrap filled " + filled);
      if (filled <= 0)       break;
      total_filled+=filled;
    }
 catch (    IOException e) {
      if (_inNIOBuffer.length() == 0) {
        _outNIOBuffer.clear();
        throw e;
      }
      break;
    }
  }
  if (total_filled == 0 && _inNIOBuffer.length() == 0) {
    if (!isOpen()) {
      _outNIOBuffer.clear();
      throw new EofException();
    }
    return false;
  }
  try {
    _inBuffer.position(_inNIOBuffer.getIndex());
    _inBuffer.limit(_inNIOBuffer.putIndex());
    _result=null;
    _result=_engine.unwrap(_inBuffer,buffer);
    if (_debug)     __log.debug(_session + " unwrap unwrap " + _result);
    _inNIOBuffer.skip(_result.bytesConsumed());
  }
  finally {
    _inBuffer.position(0);
    _inBuffer.limit(_inBuffer.capacity());
  }
switch (_result.getStatus()) {
case BUFFER_OVERFLOW:
    throw new IllegalStateException(_result.toString());
case BUFFER_UNDERFLOW:
  if (Log.isDebugEnabled())   Log.debug("unwrap {}",_result);
if (!isOpen()) {
  _inNIOBuffer.clear();
  _outNIOBuffer.clear();
  throw new EofException();
}
return (total_filled > 0);
case CLOSED:
_closing=true;
case OK:
return total_filled > 0 || _result.bytesConsumed() > 0 || _result.bytesProduced() > 0;
default :
Log.warn("unwrap " + _result);
throw new IOException(_result.toString());
}
}
