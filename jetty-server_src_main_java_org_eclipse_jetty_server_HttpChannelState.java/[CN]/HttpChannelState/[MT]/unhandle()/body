{
synchronized (this) {
    if (DEBUG)     LOG.debug("{} unhandle {}",this,_state);
switch (_state) {
case DISPATCHED:
case ASYNC_IO:
      break;
default :
    throw new IllegalStateException(this.getStatusString());
}
if (_asyncRead) {
  _state=State.ASYNC_IO;
  _asyncRead=false;
  return Action.READ_CALLBACK;
}
if (_asyncWrite) {
  _asyncWrite=false;
  _state=State.ASYNC_IO;
  return Action.WRITE_CALLBACK;
}
if (_async != null) {
  _initial=false;
switch (_async) {
case COMPLETE:
    _state=State.COMPLETING;
  _async=null;
return Action.COMPLETE;
case DISPATCH:
_state=State.DISPATCHED;
_async=null;
return Action.ASYNC_DISPATCH;
case EXPIRED:
_state=State.DISPATCHED;
_async=null;
return Action.ASYNC_EXPIRED;
case EXPIRING:
case STARTED:
scheduleTimeout();
_state=State.ASYNC_WAIT;
return Action.WAIT;
}
}
_state=State.COMPLETING;
return Action.COMPLETE;
}
}
