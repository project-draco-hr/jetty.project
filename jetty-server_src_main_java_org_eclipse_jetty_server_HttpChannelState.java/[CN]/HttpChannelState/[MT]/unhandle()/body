{
  Action action;
  AsyncContextEvent schedule_event=null;
  boolean read_interested=false;
  if (DEBUG)   LOG.debug("{} unhandle {}",this,_state);
  try (Locker.Lock lock=_locker.lock()){
switch (_state) {
case COMPLETED:
      return Action.COMPLETED;
case DISPATCHED:
case ASYNC_IO:
    break;
default :
  throw new IllegalStateException(this.getStatusStringLocked());
}
if (_async != null) {
_initial=false;
switch (_async) {
case COMPLETE:
  _state=State.COMPLETING;
_async=null;
action=Action.COMPLETING;
break;
case DISPATCH:
_state=State.DISPATCHED;
_async=null;
action=Action.ASYNC_DISPATCH;
break;
case EXPIRED:
_state=State.DISPATCHED;
_async=null;
action=Action.ERROR_DISPATCH;
break;
case STARTED:
if (_asyncReadUnready && _asyncReadPossible) {
_state=State.ASYNC_IO;
_asyncReadUnready=false;
action=Action.READ_CALLBACK;
}
 else if (_asyncWrite) {
_asyncWrite=false;
_state=State.ASYNC_IO;
action=Action.WRITE_CALLBACK;
}
 else {
schedule_event=_event;
read_interested=_asyncReadUnready;
_state=State.ASYNC_WAIT;
action=Action.WAIT;
}
break;
case EXPIRING:
schedule_event=_event;
_state=State.ASYNC_WAIT;
action=Action.WAIT;
break;
case ERRORING:
_state=State.DISPATCHED;
action=Action.ERROR_DISPATCH;
break;
case ERRORED:
_state=State.DISPATCHED;
action=Action.ASYNC_ERROR;
_async=null;
break;
default :
_state=State.COMPLETING;
action=Action.COMPLETING;
break;
}
}
 else {
_state=State.COMPLETING;
action=Action.COMPLETING;
}
}
 if (schedule_event != null) scheduleTimeout(schedule_event);
if (read_interested) _channel.asyncReadFillInterested();
return action;
}
