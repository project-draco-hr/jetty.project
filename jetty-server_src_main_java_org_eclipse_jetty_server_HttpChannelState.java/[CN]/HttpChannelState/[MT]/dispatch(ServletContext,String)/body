{
  boolean dispatch;
synchronized (this) {
    if (_async != Async.STARTED && _async != Async.EXPIRING)     throw new IllegalStateException("AsyncContext#dispath " + this.getStatusString());
    _async=Async.DISPATCH;
    if (context != null)     _event.setDispatchContext(context);
    if (path != null)     _event.setDispatchPath(path);
switch (_state) {
case DISPATCHED:
case ASYNC_IO:
      dispatch=false;
    break;
case ASYNC_WAIT:
  _state=State.ASYNC_WOKEN;
dispatch=true;
break;
case ASYNC_WOKEN:
dispatch=false;
break;
default :
LOG.warn("async dispatched when complete {}",this);
dispatch=false;
break;
}
}
cancelTimeout();
if (dispatch) scheduleDispatch();
}
