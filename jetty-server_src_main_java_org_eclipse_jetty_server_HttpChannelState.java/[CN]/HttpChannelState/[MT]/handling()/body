{
synchronized (this) {
switch (_state) {
case IDLE:
      _initial=true;
    _state=State.DISPATCHED;
  if (_lastAsyncListeners != null)   _lastAsyncListeners.clear();
if (_asyncListeners != null) _asyncListeners.clear();
 else {
  _asyncListeners=_lastAsyncListeners;
  _lastAsyncListeners=null;
}
return Action.REQUEST_DISPATCH;
case COMPLETING:
return Action.COMPLETE;
case COMPLETED:
return Action.RECYCLE;
case ASYNCWAIT:
if (_asyncIO) {
_state=State.ASYNCIO;
_asyncIO=false;
return Action.IO_CALLBACK;
}
if (_async != null) {
Async async=_async;
switch (async) {
case COMPLETE:
_state=State.COMPLETING;
return Action.COMPLETE;
case DISPATCH:
_state=State.DISPATCHED;
_async=null;
return Action.ASYNC_DISPATCH;
case EXPIRING:
break;
case EXPIRED:
_state=State.DISPATCHED;
_async=null;
return Action.ASYNC_EXPIRED;
case STARTED:
LOG.warn("TODO Fix this double dispatch",new IllegalStateException(this.getStatusString()));
return Action.WAIT;
}
}
return Action.WAIT;
default :
throw new IllegalStateException(this.getStatusString());
}
}
}
