{
  LOG.debug("{} onReadable {}",this,_channel.isIdle());
  int filled=-2;
  try {
    setCurrentConnection(this);
    while (true) {
      if (BufferUtil.isEmpty(_requestBuffer)) {
        if (_requestBuffer == null)         _requestBuffer=_bufferPool.acquire(_httpConfig.getRequestHeaderSize(),false);
        filled=getEndPoint().fill(_requestBuffer);
        LOG.debug("{} filled {}",this,filled);
        if (filled == 0) {
          releaseRequestBuffer();
          fillInterested();
          return;
        }
 else         if (filled < 0) {
          _parser.inputShutdown();
          if (getEndPoint().isOutputShutdown())           getEndPoint().close();
 else           getEndPoint().shutdownOutput();
          releaseRequestBuffer();
          return;
        }
 else {
          _headerBytes+=filled;
        }
      }
      if (_parser.parseNext(_requestBuffer)) {
        _headerBytes=0;
        releaseRequestBuffer();
        if (!_channel.getRequest().isPersistent())         _generator.setPersistent(false);
        boolean complete=_channel.handle();
        if (_channel.getResponse().getStatus() == HttpStatus.SWITCHING_PROTOCOLS_101) {
          Connection connection=(Connection)_channel.getRequest().getAttribute(UPGRADE_CONNECTION_ATTRIBUTE);
          if (connection != null) {
            LOG.debug("Upgrade from {} to {}",this,connection);
            getEndPoint().setConnection(connection);
          }
        }
        HttpConnection.this.reset();
        if (getCurrentConnection() != HttpConnection.this) {
          if (_parser.isStart()) {
            if (_requestBuffer == null) {
              fillInterested();
            }
 else             if (getConnector().isStarted()) {
              LOG.debug("{} pipelined",this);
              try {
                getExecutor().execute(new Runnable(){
                  @Override public void run(){
                    onFillable();
                  }
                }
);
              }
 catch (              RejectedExecutionException e) {
                if (getConnector().isStarted())                 LOG.warn(e);
 else                 LOG.ignore(e);
                getEndPoint().close();
              }
            }
 else {
              getEndPoint().close();
            }
          }
          if (_parser.isClosed() && !getEndPoint().isOutputShutdown()) {
            LOG.warn("Endpoint output not shutdown when seeking EOF");
            getEndPoint().shutdownOutput();
          }
        }
        if (getEndPoint().isOpen() && getEndPoint().isOutputShutdown()) {
          fillInterested();
        }
        if (getEndPoint().getConnection() != this)         return;
      }
 else       if (_headerBytes >= _httpConfig.getRequestHeaderSize()) {
        _parser.reset();
        _parser.close();
        _channel.getEventHandler().badMessage(HttpStatus.REQUEST_ENTITY_TOO_LARGE_413,null);
      }
    }
  }
 catch (  IOException e) {
    if (_parser.isIdle())     LOG.debug(e);
 else     LOG.warn(this.toString(),e);
    getEndPoint().close();
  }
catch (  Exception e) {
    LOG.warn(this.toString(),e);
    getEndPoint().close();
  }
 finally {
    setCurrentConnection(null);
  }
}
