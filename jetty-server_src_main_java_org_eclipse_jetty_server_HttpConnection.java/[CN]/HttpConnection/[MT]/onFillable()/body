{
  LOG.debug("{} onReadable {}",this,_channel.isIdle());
  try {
    _thread=Thread.currentThread();
    setCurrentConnection(this);
    while (true) {
      if (BufferUtil.isEmpty(_requestBuffer)) {
        if (_requestBuffer == null)         _requestBuffer=_bufferPool.acquire(_connector.getRequestHeaderSize(),false);
        int filled=getEndPoint().fill(_requestBuffer);
        LOG.debug("{} filled {}",this,filled);
        if (filled == 0) {
          fillInterested();
          releaseRequestBuffer();
          return;
        }
 else         if (filled < 0) {
          _parser.inputShutdown();
          getEndPoint().shutdownOutput();
          releaseRequestBuffer();
          return;
        }
 else {
          _headerBytes+=filled;
        }
      }
      if (_parser.parseNext(_requestBuffer)) {
        releaseRequestBuffer();
        _headerBytes=0;
        if (!_parser.isPersistent())         _generator.setPersistent(false);
        _channel.handle();
        if (_channel.isSuspended()) {
          if (_httpInput.available() == 0)           releaseRequestBuffer();
          return;
        }
        if (getEndPoint().getAsyncConnection() != this) {
          getEndPoint().getAsyncConnection().onOpen();
          return;
        }
      }
 else       if (_headerBytes >= _connector.getRequestHeaderSize()) {
        _parser.reset();
        _parser.close();
        _channel.getEventHandler().badMessage(HttpStatus.REQUEST_ENTITY_TOO_LARGE_413,null);
      }
    }
  }
 catch (  IOException e) {
    if (_parser.isIdle())     LOG.debug(e);
 else     LOG.warn(this.toString(),e);
    getEndPoint().close();
  }
catch (  Exception e) {
    LOG.warn(this.toString(),e);
    getEndPoint().close();
  }
 finally {
    _thread=null;
    setCurrentConnection(null);
  }
}
