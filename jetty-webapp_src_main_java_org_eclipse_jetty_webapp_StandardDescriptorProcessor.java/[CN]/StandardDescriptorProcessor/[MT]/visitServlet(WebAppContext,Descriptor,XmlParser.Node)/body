{
  String id=node.getAttribute("id");
  String servlet_name=node.getString("servlet-name",false,true);
  ServletHolder holder=context.getServletHandler().getServlet(servlet_name);
  if (holder == null) {
    holder=context.getServletHandler().newServletHolder(Holder.Source.DESCRIPTOR);
    holder.setName(servlet_name);
    context.getServletHandler().addServlet(holder);
  }
  Iterator<?> iParamsIter=node.iterator("init-param");
  while (iParamsIter.hasNext()) {
    XmlParser.Node paramNode=(XmlParser.Node)iParamsIter.next();
    String pname=paramNode.getString("param-name",false,true);
    String pvalue=paramNode.getString("param-value",false,true);
    Origin origin=context.getMetaData().getOrigin(servlet_name + ".servlet.init-param." + pname);
switch (origin) {
case NotSet:
{
        holder.setInitParameter(pname,pvalue);
        context.getMetaData().setOrigin(servlet_name + ".servlet.init-param." + pname,descriptor);
        break;
      }
case WebXml:
case WebDefaults:
case WebOverride:
{
      if (!(descriptor instanceof FragmentDescriptor)) {
        holder.setInitParameter(pname,pvalue);
        context.getMetaData().setOrigin(servlet_name + ".servlet.init-param." + pname,descriptor);
      }
      break;
    }
case WebFragment:
{
    if (!holder.getInitParameter(pname).equals(pvalue))     throw new IllegalStateException("Mismatching init-param " + pname + "="+ pvalue+ " in "+ descriptor.getResource());
    break;
  }
}
}
String servlet_class=node.getString("servlet-class",false,true);
String jspServletName=null;
String jspServletClass=null;
;
boolean hasJSP=false;
if (id != null && id.equals("jsp")) {
jspServletName=servlet_name;
jspServletClass=servlet_class;
try {
Loader.loadClass(this.getClass(),servlet_class);
hasJSP=true;
}
 catch (ClassNotFoundException e) {
LOG.info("NO JSP Support for {}, did not find {}",context.getContextPath(),servlet_class);
jspServletClass=servlet_class="org.eclipse.jetty.servlet.NoJspServlet";
}
if (holder.getInitParameter("scratchdir") == null) {
File tmp=context.getTempDirectory();
File scratch=new File(tmp,"jsp");
if (!scratch.exists()) scratch.mkdir();
holder.setInitParameter("scratchdir",scratch.getAbsolutePath());
if ("?".equals(holder.getInitParameter("classpath"))) {
  String classpath=context.getClassPath();
  LOG.debug("classpath=" + classpath);
  if (classpath != null)   holder.setInitParameter("classpath",classpath);
}
}
context.setAttribute("org.apache.catalina.jsp_classpath",context.getClassPath());
holder.setInitParameter("com.sun.appserv.jsp.classpath",getSystemClassPath(context));
}
if (servlet_class != null) {
((WebDescriptor)descriptor).addClassName(servlet_class);
Origin o=context.getMetaData().getOrigin(servlet_name + ".servlet.servlet-class");
switch (o) {
case NotSet:
{
  holder.setClassName(servlet_class);
  context.getMetaData().setOrigin(servlet_name + ".servlet.servlet-class",descriptor);
  break;
}
case WebXml:
case WebDefaults:
case WebOverride:
{
if (!(descriptor instanceof FragmentDescriptor)) {
  holder.setClassName(servlet_class);
  context.getMetaData().setOrigin(servlet_name + ".servlet.servlet-class",descriptor);
}
break;
}
case WebFragment:
{
if (!servlet_class.equals(holder.getClassName())) throw new IllegalStateException("Conflicting servlet-class " + servlet_class + " in "+ descriptor.getResource());
break;
}
}
}
String jsp_file=node.getString("jsp-file",false,true);
if (jsp_file != null) {
holder.setForcedPath(jsp_file);
holder.setClassName(jspServletClass);
holder.setInitParameter("com.sun.appserv.jsp.classpath",getSystemClassPath(context));
}
XmlParser.Node startup=node.get("load-on-startup");
if (startup != null) {
String s=startup.toString(false,true).toLowerCase();
int order=0;
if (s.startsWith("t")) {
LOG.warn("Deprecated boolean load-on-startup.  Please use integer");
order=1;
}
 else {
try {
if (s != null && s.trim().length() > 0) order=Integer.parseInt(s);
}
 catch (Exception e) {
LOG.warn("Cannot parse load-on-startup " + s + ". Please use integer");
LOG.ignore(e);
}
}
Origin o=context.getMetaData().getOrigin(servlet_name + ".servlet.load-on-startup");
switch (o) {
case NotSet:
{
holder.setInitOrder(order);
context.getMetaData().setOrigin(servlet_name + ".servlet.load-on-startup",descriptor);
break;
}
case WebXml:
case WebDefaults:
case WebOverride:
{
if (!(descriptor instanceof FragmentDescriptor)) {
holder.setInitOrder(order);
context.getMetaData().setOrigin(servlet_name + ".servlet.load-on-startup",descriptor);
}
break;
}
case WebFragment:
{
if (order != holder.getInitOrder()) throw new IllegalStateException("Conflicting load-on-startup value in " + descriptor.getResource());
break;
}
}
}
Iterator sRefsIter=node.iterator("security-role-ref");
while (sRefsIter.hasNext()) {
XmlParser.Node securityRef=(XmlParser.Node)sRefsIter.next();
String roleName=securityRef.getString("role-name",false,true);
String roleLink=securityRef.getString("role-link",false,true);
if (roleName != null && roleName.length() > 0 && roleLink != null && roleLink.length() > 0) {
if (LOG.isDebugEnabled()) LOG.debug("link role " + roleName + " to "+ roleLink+ " for "+ this);
Origin o=context.getMetaData().getOrigin(servlet_name + ".servlet.role-name." + roleName);
switch (o) {
case NotSet:
{
holder.setUserRoleLink(roleName,roleLink);
context.getMetaData().setOrigin(servlet_name + ".servlet.role-name." + roleName,descriptor);
break;
}
case WebXml:
case WebDefaults:
case WebOverride:
{
if (!(descriptor instanceof FragmentDescriptor)) {
holder.setUserRoleLink(roleName,roleLink);
context.getMetaData().setOrigin(servlet_name + ".servlet.role-name." + roleName,descriptor);
}
break;
}
case WebFragment:
{
if (!holder.getUserRoleLink(roleName).equals(roleLink)) throw new IllegalStateException("Conflicting role-link for role-name " + roleName + " for servlet "+ servlet_name+ " in "+ descriptor.getResource());
break;
}
}
}
 else {
LOG.warn("Ignored invalid security-role-ref element: " + "servlet-name=" + holder.getName() + ", "+ securityRef);
}
}
XmlParser.Node run_as=node.get("run-as");
if (run_as != null) {
String roleName=run_as.getString("role-name",false,true);
if (roleName != null) {
Origin o=context.getMetaData().getOrigin(servlet_name + ".servlet.run-as");
switch (o) {
case NotSet:
{
holder.setRunAsRole(roleName);
context.getMetaData().setOrigin(servlet_name + ".servlet.run-as",descriptor);
break;
}
case WebXml:
case WebDefaults:
case WebOverride:
{
if (!(descriptor instanceof FragmentDescriptor)) {
holder.setRunAsRole(roleName);
context.getMetaData().setOrigin(servlet_name + ".servlet.run-as",descriptor);
}
break;
}
case WebFragment:
{
if (!holder.getRunAsRole().equals(roleName)) throw new IllegalStateException("Conflicting run-as role " + roleName + " for servlet "+ servlet_name+ " in "+ descriptor.getResource());
break;
}
}
}
}
String async=node.getString("async-supported",false,true);
if (async != null) {
boolean val=async.length() == 0 || Boolean.valueOf(async);
Origin o=context.getMetaData().getOrigin(servlet_name + ".servlet.async-supported");
switch (o) {
case NotSet:
{
holder.setAsyncSupported(val);
context.getMetaData().setOrigin(servlet_name + ".servlet.async-supported",descriptor);
break;
}
case WebXml:
case WebDefaults:
case WebOverride:
{
if (!(descriptor instanceof FragmentDescriptor)) {
holder.setAsyncSupported(val);
context.getMetaData().setOrigin(servlet_name + ".servlet.async-supported",descriptor);
}
break;
}
case WebFragment:
{
if (holder.isAsyncSupported() != val) throw new IllegalStateException("Conflicting async-supported=" + async + " for servlet "+ servlet_name+ " in "+ descriptor.getResource());
break;
}
}
}
String enabled=node.getString("enabled",false,true);
if (enabled != null) {
boolean is_enabled=enabled.length() == 0 || Boolean.valueOf(enabled);
Origin o=context.getMetaData().getOrigin(servlet_name + ".servlet.enabled");
switch (o) {
case NotSet:
{
context.getMetaData().setOrigin(servlet_name + ".servlet.enabled",descriptor);
break;
}
case WebXml:
case WebDefaults:
case WebOverride:
{
if (!(descriptor instanceof FragmentDescriptor)) {
context.getMetaData().setOrigin(servlet_name + ".servlet.enabled",descriptor);
}
break;
}
case WebFragment:
{
break;
}
}
}
XmlParser.Node multipart=node.get("multipart-config");
if (multipart != null) {
String location=multipart.getString("location",false,true);
String maxFile=multipart.getString("max-file-size",false,true);
String maxRequest=multipart.getString("max-request-size",false,true);
String threshold=multipart.getString("file-size-threshold",false,true);
MultipartConfigElement element=new MultipartConfigElement(location,(maxFile == null || "".equals(maxFile) ? -1L : Long.parseLong(maxFile)),(maxRequest == null || "".equals(maxRequest) ? -1L : Long.parseLong(maxRequest)),(threshold == null || "".equals(threshold) ? 0 : Integer.parseInt(threshold)));
Origin o=context.getMetaData().getOrigin(servlet_name + ".servlet.multipart-config");
switch (o) {
case NotSet:
{
holder.getRegistration().setMultipartConfig(element);
context.getMetaData().setOrigin(servlet_name + ".servlet.multipart-config",descriptor);
break;
}
case WebXml:
case WebDefaults:
case WebOverride:
{
if (!(descriptor instanceof FragmentDescriptor)) {
holder.getRegistration().setMultipartConfig(element);
context.getMetaData().setOrigin(servlet_name + ".servlet.multipart-config",descriptor);
}
break;
}
case WebFragment:
{
MultipartConfigElement cfg=((ServletHolder.Registration)holder.getRegistration()).getMultipartConfig();
if (cfg.getMaxFileSize() != element.getMaxFileSize()) throw new IllegalStateException("Conflicting multipart-config max-file-size for servlet " + servlet_name + " in "+ descriptor.getResource());
if (cfg.getMaxRequestSize() != element.getMaxRequestSize()) throw new IllegalStateException("Conflicting multipart-config max-request-size for servlet " + servlet_name + " in "+ descriptor.getResource());
if (cfg.getFileSizeThreshold() != element.getFileSizeThreshold()) throw new IllegalStateException("Conflicting multipart-config file-size-threshold for servlet " + servlet_name + " in "+ descriptor.getResource());
if ((cfg.getLocation() != null && (element.getLocation() == null || element.getLocation().length() == 0)) || (cfg.getLocation() == null && (element.getLocation() != null || element.getLocation().length() > 0))) throw new IllegalStateException("Conflicting multipart-config location for servlet " + servlet_name + " in "+ descriptor.getResource());
break;
}
}
}
}
