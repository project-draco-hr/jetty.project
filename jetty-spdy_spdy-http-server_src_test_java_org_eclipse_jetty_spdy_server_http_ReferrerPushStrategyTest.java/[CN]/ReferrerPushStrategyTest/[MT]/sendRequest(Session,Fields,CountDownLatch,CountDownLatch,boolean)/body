{
  LOG.info("sendRequest. headers={},resetPush={}",requestHeaders,resetPush);
  final CountDownLatch dataReceivedLatch=new CountDownLatch(1);
  session.syn(new SynInfo(requestHeaders,true),new StreamFrameListener.Adapter(){
    @Override public StreamFrameListener onPush(    Stream stream,    PushInfo pushInfo){
      if (pushSynHeadersValid != null)       validateHeaders(pushInfo.getHeaders(),pushSynHeadersValid);
      assertThat("Stream is unidirectional",stream.isUnidirectional(),is(true));
      assertThat("URI header ends with css",pushInfo.getHeaders().get(HTTPSPDYHeader.URI.name(version)).value().endsWith("" + ".css"),is(true));
      if (resetPush)       stream.getSession().rst(new RstInfo(stream.getId(),StreamStatus.REFUSED_STREAM),new Callback.Adapter());
      return new StreamFrameListener.Adapter(){
        @Override public void onData(        Stream stream,        DataInfo dataInfo){
          dataInfo.consume(dataInfo.length());
          pushDataLatch.countDown();
        }
      }
;
    }
    @Override public void onReply(    Stream stream,    ReplyInfo replyInfo){
      assertThat(replyInfo.getHeaders().get(HTTPSPDYHeader.STATUS.name(version)).value(),is("200 OK"));
    }
    @Override public void onData(    Stream stream,    DataInfo dataInfo){
      dataInfo.consume(dataInfo.length());
      if (dataInfo.isClose())       dataReceivedLatch.countDown();
    }
  }
,new Promise.Adapter<Stream>());
  assertThat(dataReceivedLatch.await(5,TimeUnit.SECONDS),is(true));
}
