{
  if (!isWriting())   return;
  try {
    while (true) {
      _buffers=compact(_buffers);
      _endp.flush(_buffers);
      for (      ByteBuffer b : _buffers) {
        if (b.hasRemaining()) {
          onIncompleteFlushed();
          return;
        }
      }
      break;
    }
    Callback<Object> callback=_callback;
    Object context=_context;
    _buffers=null;
    _callback=null;
    _context=null;
    if (!_writing.compareAndSet(true,false))     throw new ConcurrentModificationException();
    callback.completed(context);
  }
 catch (  IOException e) {
    Callback<Object> callback=_callback;
    Object context=_context;
    _buffers=null;
    _callback=null;
    _context=null;
    if (!_writing.compareAndSet(true,false))     throw new ConcurrentModificationException();
    callback.failed(context,e);
  }
  return;
}
