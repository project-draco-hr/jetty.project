{
  Connection connection=this;
  boolean progress=true;
  try {
    boolean failed=false;
    int loops=10000;
    while (_endp.isOpen() && (_parser.isMoreInBuffer() || _endp.isBufferingInput() || progress)) {
      if (loops-- < 0) {
        System.err.println("LOOPING!!!");
        System.err.println(this);
        System.err.println(_endp);
        System.err.println(((SelectChannelEndPoint)_endp).getSelectManager().dump());
        System.exit(1);
      }
      progress=false;
      HttpExchange exchange=_exchange;
      try {
        if (!_generator.isCommitted() && exchange != null && exchange.getStatus() == HttpExchange.STATUS_WAITING_FOR_COMMIT) {
          progress=true;
          commitRequest();
        }
        if (_generator.isCommitted() && !_generator.isComplete()) {
          if (_generator.flushBuffer() > 0)           progress=true;
          if (_generator.isState(AbstractGenerator.STATE_CONTENT)) {
            if (_requestContentChunk == null)             _requestContentChunk=exchange.getRequestContentChunk(null);
            if (_requestContentChunk == null) {
              progress=true;
              _generator.complete();
            }
 else             if (_generator.isEmpty()) {
              progress=true;
              Buffer chunk=_requestContentChunk;
              _requestContentChunk=exchange.getRequestContentChunk(null);
              _generator.addContent(chunk,_requestContentChunk == null);
            }
          }
        }
        if (_generator.isComplete() && !_requestComplete) {
          progress=true;
          _requestComplete=true;
          exchange.getEventListener().onRequestComplete();
        }
        if (_endp.isBufferingOutput())         _endp.flush();
        if (!_parser.isComplete() && _parser.parseAvailable())         progress=true;
        if (_asyncEndp.hasProgressed())         progress=true;
      }
 catch (      Throwable e) {
        LOG.debug("Failure on " + _exchange,e);
        if (e instanceof ThreadDeath)         throw (ThreadDeath)e;
        failed=true;
synchronized (this) {
          if (exchange != null) {
            if (exchange.getStatus() != HttpExchange.STATUS_CANCELLING && exchange.getStatus() != HttpExchange.STATUS_CANCELLED && !exchange.isDone()) {
              exchange.setStatus(HttpExchange.STATUS_EXCEPTED);
              exchange.getEventListener().onException(e);
            }
          }
 else {
            if (e instanceof IOException)             throw (IOException)e;
            if (e instanceof Error)             throw (Error)e;
            if (e instanceof RuntimeException)             throw (RuntimeException)e;
            throw new RuntimeException(e);
          }
        }
      }
 finally {
        boolean complete=failed || _generator.isComplete() && _parser.isComplete();
        if (complete) {
          boolean persistent=!failed && _parser.isPersistent() && _generator.isPersistent();
          _generator.setPersistent(persistent);
          reset();
          if (persistent)           _endp.setMaxIdleTime((int)_destination.getHttpClient().getIdleTimeout());
synchronized (this) {
            exchange=_exchange;
            _exchange=null;
            if (exchange != null) {
              exchange.cancelTimeout(_destination.getHttpClient());
            }
            if (_status == HttpStatus.SWITCHING_PROTOCOLS_101) {
              Connection switched=exchange.onSwitchProtocol(_endp);
              if (switched != null)               connection=switched;
{
                _pipeline=null;
                if (_pipeline != null)                 _destination.send(_pipeline);
                _pipeline=null;
                connection=switched;
              }
            }
            if (_pipeline != null) {
              if (!persistent || connection != this)               _destination.send(_pipeline);
 else               _exchange=_pipeline;
              _pipeline=null;
            }
            if (_exchange == null && !isReserved())             _destination.returnConnection(this,!persistent);
          }
        }
      }
    }
  }
  finally {
    _parser.returnBuffers();
    _generator.returnBuffers();
  }
  return connection;
}
