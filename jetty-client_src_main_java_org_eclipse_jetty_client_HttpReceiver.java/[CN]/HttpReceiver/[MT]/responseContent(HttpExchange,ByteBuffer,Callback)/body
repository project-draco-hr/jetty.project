{
  out:   while (true) {
    ResponseState current=responseState.get();
switch (current) {
case HEADERS:
case CONTENT:
{
        if (updateResponseState(current,ResponseState.TRANSIENT))         break out;
        break;
      }
default :
{
      return false;
    }
}
}
HttpResponse response=exchange.getResponse();
if (LOG.isDebugEnabled()) LOG.debug("Response content {}{}{}",response,System.lineSeparator(),BufferUtil.toDetailString(buffer));
ResponseNotifier notifier=getHttpDestination().getResponseNotifier();
List<Response.ResponseListener> listeners=exchange.getConversation().getResponseListeners();
ContentDecoder decoder=this.decoder;
if (decoder == null) {
notifier.notifyContent(listeners,response,buffer,callback);
}
 else {
List<ByteBuffer> decodeds=new ArrayList<>(2);
while (buffer.hasRemaining()) {
  ByteBuffer decoded=decoder.decode(buffer);
  if (!decoded.hasRemaining())   continue;
  decodeds.add(decoded);
  if (LOG.isDebugEnabled())   LOG.debug("Response content decoded ({}) {}{}{}",decoder,response,System.lineSeparator(),BufferUtil.toDetailString(decoded));
}
if (decodeds.isEmpty()) {
  callback.succeeded();
}
 else {
  Callback partial=new Callback.Adapter(){
    @Override public void failed(    Throwable x){
      callback.failed(x);
    }
  }
;
  for (int i=1, size=decodeds.size(); i <= size; ++i)   notifier.notifyContent(listeners,response,decodeds.get(i - 1),i < size ? partial : callback);
}
}
if (!updateResponseState(ResponseState.TRANSIENT,ResponseState.CONTENT)) terminateResponse(exchange,failure);
return true;
}
