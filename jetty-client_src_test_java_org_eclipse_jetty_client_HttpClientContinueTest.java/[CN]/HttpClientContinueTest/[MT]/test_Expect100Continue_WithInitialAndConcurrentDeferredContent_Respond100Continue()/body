{
  start(new AbstractHandler(){
    @Override public void handle(    String target,    Request baseRequest,    HttpServletRequest request,    HttpServletResponse response) throws IOException, ServletException {
      baseRequest.setHandled(true);
      IO.copy(request.getInputStream(),response.getOutputStream());
    }
  }
);
  final byte[] chunk1=new byte[]{0,1,2,3};
  final byte[] chunk2=new byte[]{4,5,6,7};
  final byte[] data=new byte[chunk1.length + chunk2.length];
  System.arraycopy(chunk1,0,data,0,chunk1.length);
  System.arraycopy(chunk2,0,data,chunk1.length,chunk2.length);
  final DeferredContentProvider content=new DeferredContentProvider(ByteBuffer.wrap(chunk1));
  List<ProtocolHandler> protocolHandlers=client.getProtocolHandlers();
  for (Iterator<ProtocolHandler> iterator=protocolHandlers.iterator(); iterator.hasNext(); ) {
    ProtocolHandler protocolHandler=iterator.next();
    if (protocolHandler instanceof ContinueProtocolHandler)     iterator.remove();
  }
  protocolHandlers.add(new ContinueProtocolHandler(client){
    @Override public Response.Listener getResponseListener(){
      return new ContinueListener(){
        @Override public void onHeaders(        Response response){
          super.onHeaders(response);
          content.offer(ByteBuffer.wrap(chunk2));
          content.close();
        }
      }
;
    }
  }
);
  final CountDownLatch latch=new CountDownLatch(1);
  client.newRequest("localhost",connector.getLocalPort()).scheme(scheme).header(HttpHeader.EXPECT.asString(),HttpHeaderValue.CONTINUE.asString()).content(content).send(new BufferingResponseListener(){
    @Override public void onComplete(    Result result){
      Assert.assertArrayEquals(data,getContent());
      latch.countDown();
    }
  }
);
  Assert.assertTrue(latch.await(5,TimeUnit.SECONDS));
}
