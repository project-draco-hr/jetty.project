{
  ServerSessionFrameListener serverSessionFrameListener=new ServerSessionFrameListener.Adapter(){
    @Override public StreamFrameListener onSyn(    Stream stream,    SynInfo synInfo){
      stream.reply(new ReplyInfo(synInfo.getHeaders(),false));
      return new StreamFrameListener.Adapter(){
        @Override public void onData(        Stream stream,        DataInfo dataInfo){
          ByteBuffer buffer=dataInfo.asByteBuffer(true);
          stream.data(new ByteBufferDataInfo(buffer,dataInfo.isClose()));
        }
      }
;
    }
  }
;
  final Session session=startClient(startServer(serverSessionFrameListener),null);
  final int iterations=500;
  final int count=50;
  final Fields headers=new Fields();
  headers.put("method","get");
  headers.put("url","/");
  headers.put("version","http/1.1");
  headers.put("host","localhost:8080");
  headers.put("content-type","application/octet-stream");
  final CountDownLatch latch=new CountDownLatch(count * iterations);
  session.addListener(new Session.StreamListener.Adapter(){
    @Override public void onStreamClosed(    Stream stream){
      latch.countDown();
    }
  }
);
  ExecutorService threadPool=Executors.newFixedThreadPool(count);
  List<Callable<Object>> tasks=new ArrayList<>();
  tasks.clear();
  for (int i=0; i < count; ++i) {
    tasks.add(new Callable<Object>(){
      @Override public Object call() throws Exception {
        synGetDataGet(session,headers,iterations);
        return null;
      }
    }
);
  }
{
    long begin=System.nanoTime();
    List<Future<Object>> futures=threadPool.invokeAll(tasks);
    for (    Future<Object> future : futures)     future.get(iterations,TimeUnit.SECONDS);
    Assert.assertTrue(latch.await(count * iterations,TimeUnit.SECONDS));
    long end=System.nanoTime();
    System.err.printf("SYN+GET+DATA+GET completed in %d ms%n",TimeUnit.NANOSECONDS.toMillis(end - begin));
  }
  tasks.clear();
  for (int i=0; i < count; ++i) {
    tasks.add(new Callable<Object>(){
      @Override public Object call() throws Exception {
        synCompletedData(session,headers,iterations);
        return null;
      }
    }
);
  }
{
    long begin=System.nanoTime();
    List<Future<Object>> futures=threadPool.invokeAll(tasks);
    for (    Future<Object> future : futures)     future.get(iterations,TimeUnit.SECONDS);
    Assert.assertTrue(latch.await(count * iterations,TimeUnit.SECONDS));
    long end=System.nanoTime();
    System.err.printf("SYN+COMPLETED+DATA completed in %d ms%n",TimeUnit.NANOSECONDS.toMillis(end - begin));
  }
  threadPool.shutdown();
}
