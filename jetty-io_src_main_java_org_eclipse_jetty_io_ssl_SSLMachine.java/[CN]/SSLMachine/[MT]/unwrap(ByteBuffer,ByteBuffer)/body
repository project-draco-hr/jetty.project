{
  boolean decrypted=false;
  while (netInput.hasRemaining()) {
    logger.debug("Decrypting from {} to {}",netInput,appInput);
    SSLEngineResult result=unwrap(engine,netInput,appInput);
    logger.debug("Decrypted from {} to {}, result {}",netInput,appInput,result);
switch (result.getStatus()) {
case OK:
{
        SSLEngineResult.HandshakeStatus handshakeStatus=result.getHandshakeStatus();
        if (handshakeStatus == SSLEngineResult.HandshakeStatus.FINISHED) {
          if (engine.getUseClientMode()) {
            logger.debug("Handshake finished (client), new SSL session");
            handshaken=true;
            return ReadState.HANDSHAKEN;
          }
 else {
            if (handshaken) {
              logger.debug("Rehandshake finished (server)");
            }
 else {
              logger.debug("Handshake finished (server), cached SSL session");
              handshaken=true;
              return ReadState.HANDSHAKEN;
            }
          }
        }
        if (result.bytesProduced() > 0) {
          decrypted=true;
          continue;
        }
        if (handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_UNWRAP)         continue;
        if (handshakeStatus == SSLEngineResult.HandshakeStatus.FINISHED || handshakeStatus == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING)         break;
        return null;
      }
case BUFFER_UNDERFLOW:
{
      return decrypted ? ReadState.DECRYPTED : ReadState.UNDERFLOW;
    }
case CLOSED:
{
    logger.debug("Close alert received from remote peer");
    remoteClosed=true;
    return decrypted ? ReadState.DECRYPTED : ReadState.CLOSED;
  }
default :
throw new IllegalStateException();
}
}
SSLEngineResult.HandshakeStatus handshakeStatus=engine.getHandshakeStatus();
if (handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_UNWRAP || engine.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) return ReadState.UNDERFLOW;
return null;
}
