{
  boolean lastFrame=isLastFrame(flags);
synchronized (WebSocketConnectionRFC6455.this) {
    if (_closedIn)     return;
  }
  try {
    byte[] array=buffer.array();
    if (isControlFrame(opcode) && buffer.length() > MAX_CONTROL_FRAME_PAYLOAD) {
      errorClose(WebSocketConnectionRFC6455.CLOSE_PROTOCOL,"Control frame too large: " + buffer.length() + " > "+ MAX_CONTROL_FRAME_PAYLOAD);
      return;
    }
    if ((flags & 0x7) != 0) {
      errorClose(WebSocketConnectionRFC6455.CLOSE_PROTOCOL,"RSV bits set 0x" + Integer.toHexString(flags));
      return;
    }
    if (_closeCode != 0 && _closeCode != CLOSE_NORMAL && opcode != OP_CLOSE) {
      return;
    }
    if (_onFrame != null) {
      if (_onFrame.onFrame(flags,opcode,array,buffer.getIndex(),buffer.length()))       return;
    }
    if (_onControl != null && isControlFrame(opcode)) {
      if (_onControl.onControl(opcode,array,buffer.getIndex(),buffer.length()))       return;
    }
switch (opcode) {
case WebSocketConnectionRFC6455.OP_CONTINUATION:
{
        if (_opcode == -1) {
          errorClose(WebSocketConnectionRFC6455.CLOSE_PROTOCOL,"Bad Continuation");
          return;
        }
        if (_onTextMessage != null && _opcode == WebSocketConnectionRFC6455.OP_TEXT) {
          if (_utf8.append(buffer.array(),buffer.getIndex(),buffer.length(),_connection.getMaxTextMessageSize())) {
            if (lastFrame) {
              _opcode=-1;
              String msg=_utf8.toString();
              _utf8.reset();
              _onTextMessage.onMessage(msg);
            }
          }
 else           textMessageTooLarge();
        }
        if (_opcode >= 0 && _connection.getMaxBinaryMessageSize() >= 0) {
          if (_aggregate != null && checkBinaryMessageSize(_aggregate.length(),buffer.length())) {
            _aggregate.put(buffer);
            if (lastFrame && _onBinaryMessage != null) {
              try {
                _onBinaryMessage.onMessage(_aggregate.array(),_aggregate.getIndex(),_aggregate.length());
              }
  finally {
                _opcode=-1;
                _aggregate.clear();
              }
            }
          }
        }
        break;
      }
case WebSocketConnectionRFC6455.OP_PING:
{
      LOG.debug("PING {}",this);
      if (!_closedOut) {
        _connection.sendControl(WebSocketConnectionRFC6455.OP_PONG,buffer.array(),buffer.getIndex(),buffer.length());
      }
      break;
    }
case WebSocketConnectionRFC6455.OP_PONG:
{
    LOG.debug("PONG {}",this);
    break;
  }
case WebSocketConnectionRFC6455.OP_CLOSE:
{
  int code=WebSocketConnectionRFC6455.CLOSE_NO_CODE;
  String message=null;
  if (buffer.length() >= 2) {
    code=(0xff & buffer.array()[buffer.getIndex()]) * 0x100 + (0xff & buffer.array()[buffer.getIndex() + 1]);
    if (code < WebSocketConnectionRFC6455.CLOSE_NORMAL || code == WebSocketConnectionRFC6455.CLOSE_UNDEFINED || code == WebSocketConnectionRFC6455.CLOSE_NO_CLOSE || code == WebSocketConnectionRFC6455.CLOSE_NO_CODE || (code > 1010 && code <= 2999) || code >= 5000) {
      errorClose(WebSocketConnectionRFC6455.CLOSE_PROTOCOL,"Invalid close code " + code);
      return;
    }
    if (buffer.length() > 2) {
      if (_utf8.append(buffer.array(),buffer.getIndex() + 2,buffer.length() - 2,_connection.getMaxTextMessageSize())) {
        message=_utf8.toString();
        _utf8.reset();
      }
    }
  }
 else   if (buffer.length() == 1) {
    errorClose(WebSocketConnectionRFC6455.CLOSE_PROTOCOL,"Invalid payload length of 1");
    return;
  }
  closeIn(code,message);
  break;
}
case WebSocketConnectionRFC6455.OP_TEXT:
{
if (_opcode != -1) {
  errorClose(WebSocketConnectionRFC6455.CLOSE_PROTOCOL,"Expected Continuation" + Integer.toHexString(opcode));
  return;
}
if (_onTextMessage != null) {
  if (_connection.getMaxTextMessageSize() <= 0) {
    if (lastFrame)     _onTextMessage.onMessage(buffer.toString(StringUtil.__UTF8));
 else {
      LOG.warn("Frame discarded. Text aggregation disabled for {}",_endp);
      errorClose(WebSocketConnectionRFC6455.CLOSE_POLICY_VIOLATION,"Text frame aggregation disabled");
    }
  }
 else   if (_utf8.append(buffer.array(),buffer.getIndex(),buffer.length(),_connection.getMaxTextMessageSize())) {
    if (lastFrame) {
      String msg=_utf8.toString();
      _utf8.reset();
      _onTextMessage.onMessage(msg);
    }
 else {
      _opcode=WebSocketConnectionRFC6455.OP_TEXT;
    }
  }
 else   textMessageTooLarge();
}
break;
}
case WebSocketConnectionRFC6455.OP_BINARY:
{
if (_opcode != -1) {
errorClose(WebSocketConnectionRFC6455.CLOSE_PROTOCOL,"Expected Continuation" + Integer.toHexString(opcode));
return;
}
if (_onBinaryMessage != null && checkBinaryMessageSize(0,buffer.length())) {
if (lastFrame) {
  _onBinaryMessage.onMessage(array,buffer.getIndex(),buffer.length());
}
 else if (_connection.getMaxBinaryMessageSize() >= 0) {
  _opcode=opcode;
  if (_aggregate == null)   _aggregate=new ByteArrayBuffer(_connection.getMaxBinaryMessageSize());
  _aggregate.put(buffer);
}
 else {
  LOG.warn("Frame discarded. Binary aggregation disabed for {}",_endp);
  errorClose(WebSocketConnectionRFC6455.CLOSE_POLICY_VIOLATION,"Binary frame aggregation disabled");
}
}
break;
}
default :
errorClose(WebSocketConnectionRFC6455.CLOSE_PROTOCOL,"Bad opcode 0x" + Integer.toHexString(opcode));
break;
}
}
 catch (Utf8Appendable.NotUtf8Exception notUtf8) {
LOG.warn("{} for {}",notUtf8,_endp);
LOG.debug(notUtf8);
errorClose(WebSocketConnectionRFC6455.CLOSE_BAD_PAYLOAD,"Invalid UTF-8");
}
catch (Throwable probablyNotUtf8) {
LOG.warn("{} for {}",probablyNotUtf8,_endp);
LOG.debug(probablyNotUtf8);
errorClose(WebSocketConnectionRFC6455.CLOSE_BAD_PAYLOAD,"Invalid Payload: " + probablyNotUtf8);
}
}
