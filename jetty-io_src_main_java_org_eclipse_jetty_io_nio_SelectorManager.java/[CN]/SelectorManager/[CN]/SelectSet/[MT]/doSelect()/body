{
  try {
    List<?> changes;
    final Selector selector;
synchronized (_changes) {
      changes=_changes[_change];
      _change=_change == 0 ? 1 : 0;
      _selecting=true;
      selector=_selector;
    }
    for (int i=0; i < changes.size(); i++) {
      try {
        Object o=changes.get(i);
        if (o instanceof EndPoint) {
          SelectChannelEndPoint endpoint=(SelectChannelEndPoint)o;
          endpoint.doUpdateKey();
        }
 else         if (o instanceof Runnable) {
          dispatch((Runnable)o);
        }
 else         if (o instanceof SocketChannel) {
          SocketChannel channel=(SocketChannel)o;
          Object att=changes.get(++i);
          if (channel.isConnected()) {
            SelectionKey key=channel.register(selector,SelectionKey.OP_READ,att);
            SelectChannelEndPoint endpoint=newEndPoint(channel,this,key);
            key.attach(endpoint);
            endpoint.schedule();
          }
 else {
            channel.register(selector,SelectionKey.OP_CONNECT,att);
          }
        }
 else         if (o instanceof ServerSocketChannel) {
          ServerSocketChannel channel=(ServerSocketChannel)o;
          channel.register(getSelector(),SelectionKey.OP_ACCEPT);
        }
 else         throw new IllegalArgumentException(o.toString());
      }
 catch (      CancelledKeyException e) {
        if (isRunning())         Log.warn(e);
 else         Log.debug(e);
      }
    }
    changes.clear();
    long idle_next=0;
    long retry_next=0;
    long now=System.currentTimeMillis();
synchronized (this) {
      _idleTimeout.setNow(now);
      _timeout.setNow(now);
      if (_lowResourcesConnections > 0 && selector.keys().size() > _lowResourcesConnections)       _idleTimeout.setDuration(_lowResourcesMaxIdleTime);
 else       _idleTimeout.setDuration(_maxIdleTime);
      idle_next=_idleTimeout.getTimeToNext();
      retry_next=_timeout.getTimeToNext();
    }
    long wait=1000L;
    if (idle_next >= 0 && wait > idle_next)     wait=idle_next;
    if (wait > 0 && retry_next >= 0 && wait > retry_next)     wait=retry_next;
    if (wait > 0) {
      long before=now;
      int selected=selector.select(wait);
      now=System.currentTimeMillis();
      _idleTimeout.setNow(now);
      _timeout.setNow(now);
      if (selected == 0 && (now - before) < wait / 2) {
        if (_jvmBug++ > 5) {
          for (          SelectionKey key : selector.keys()) {
            if (key.interestOps() == 0 && key.isValid())             key.cancel();
          }
          selector.selectNow();
        }
      }
 else       _jvmBug=0;
    }
 else {
      selector.selectNow();
      _jvmBug=0;
    }
    if (_selector == null || !selector.isOpen())     return;
    for (    SelectionKey key : selector.selectedKeys()) {
      try {
        if (!key.isValid()) {
          key.cancel();
          SelectChannelEndPoint endpoint=(SelectChannelEndPoint)key.attachment();
          if (endpoint != null)           endpoint.doUpdateKey();
          continue;
        }
        Object att=key.attachment();
        if (att instanceof SelectChannelEndPoint) {
          ((SelectChannelEndPoint)att).schedule();
        }
 else         if (key.isAcceptable()) {
          SocketChannel channel=acceptChannel(key);
          if (channel == null)           continue;
          channel.configureBlocking(false);
          _nextSet=++_nextSet % _selectSet.length;
          if (_nextSet == _setID) {
            SelectionKey cKey=channel.register(_selectSet[_nextSet].getSelector(),SelectionKey.OP_READ);
            SelectChannelEndPoint endpoint=newEndPoint(channel,_selectSet[_nextSet],cKey);
            cKey.attach(endpoint);
            if (endpoint != null)             endpoint.schedule();
          }
 else {
            _selectSet[_nextSet].addChange(channel);
            _selectSet[_nextSet].wakeup();
          }
        }
 else         if (key.isConnectable()) {
          SocketChannel channel=(SocketChannel)key.channel();
          boolean connected=false;
          try {
            connected=channel.finishConnect();
          }
 catch (          Exception e) {
            connectionFailed(channel,e,att);
          }
 finally {
            if (connected) {
              key.interestOps(SelectionKey.OP_READ);
              SelectChannelEndPoint endpoint=newEndPoint(channel,this,key);
              key.attach(endpoint);
              endpoint.schedule();
            }
 else {
              key.cancel();
            }
          }
        }
 else {
          SocketChannel channel=(SocketChannel)key.channel();
          SelectChannelEndPoint endpoint=newEndPoint(channel,this,key);
          key.attach(endpoint);
          if (key.isReadable())           endpoint.schedule();
        }
        key=null;
      }
 catch (      CancelledKeyException e) {
        Log.ignore(e);
      }
catch (      Exception e) {
        if (isRunning())         Log.warn(e);
 else         Log.ignore(e);
        if (key != null && !(key.channel() instanceof ServerSocketChannel) && key.isValid())         key.cancel();
      }
    }
    selector.selectedKeys().clear();
    _idleTimeout.tick(now);
    _timeout.tick(now);
  }
 catch (  CancelledKeyException e) {
    Log.ignore(e);
  }
 finally {
    _selecting=false;
  }
}
