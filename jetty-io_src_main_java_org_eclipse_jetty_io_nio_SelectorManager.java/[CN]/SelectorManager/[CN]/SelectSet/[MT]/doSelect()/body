{
  try {
    _selecting=Thread.currentThread();
    final Selector selector=_selector;
    Object change;
    int changes=_changes.size();
    while (changes-- > 0 && (change=_changes.poll()) != null) {
      try {
        if (change instanceof EndPoint) {
          SelectChannelEndPoint endpoint=(SelectChannelEndPoint)change;
          endpoint.doUpdateKey();
        }
 else         if (change instanceof ChannelAndAttachment) {
          final ChannelAndAttachment asc=(ChannelAndAttachment)change;
          final SelectableChannel channel=asc._channel;
          final Object att=asc._attachment;
          if ((channel instanceof SocketChannel) && ((SocketChannel)channel).isConnected()) {
            SelectionKey key=channel.register(selector,SelectionKey.OP_READ,att);
            SelectChannelEndPoint endpoint=createEndPoint((SocketChannel)channel,key);
            key.attach(endpoint);
            endpoint.schedule();
          }
 else           if (channel.isOpen()) {
            channel.register(selector,SelectionKey.OP_CONNECT,att);
          }
        }
 else         if (change instanceof SocketChannel) {
          final SocketChannel channel=(SocketChannel)change;
          SelectionKey key=channel.register(selector,SelectionKey.OP_READ,null);
          SelectChannelEndPoint endpoint=createEndPoint(channel,key);
          key.attach(endpoint);
          endpoint.schedule();
        }
 else         if (change instanceof Runnable) {
          dispatch((Runnable)change);
        }
 else         throw new IllegalArgumentException(change.toString());
      }
 catch (      Exception e) {
        if (isRunning())         Log.warn(e);
 else         Log.debug(e);
      }
catch (      Error e) {
        if (isRunning())         Log.warn(e);
 else         Log.debug(e);
      }
    }
    int selected=selector.selectNow();
    _selects++;
    long now=System.currentTimeMillis();
    if (selected == 0 && selector.selectedKeys().isEmpty()) {
      if (_pausing) {
        try {
          Thread.sleep(__BUSY_PAUSE);
        }
 catch (        InterruptedException e) {
          Log.ignore(e);
        }
        now=System.currentTimeMillis();
      }
      _timeout.setNow(now);
      long to_next_timeout=_timeout.getTimeToNext();
      long wait=_changes.size() == 0 ? __IDLE_TICK : 0L;
      if (wait > 0 && to_next_timeout >= 0 && wait > to_next_timeout)       wait=to_next_timeout;
      if (wait > 0) {
        long before=now;
        selected=selector.select(wait);
        _selects++;
        now=System.currentTimeMillis();
        _timeout.setNow(now);
        if (__JVMBUG_THRESHHOLD > 0)         checkJvmBugs(before,now,wait,selected);
      }
    }
    if (_selector == null || !selector.isOpen())     return;
    for (    SelectionKey key : selector.selectedKeys()) {
      try {
        if (!key.isValid()) {
          key.cancel();
          SelectChannelEndPoint endpoint=(SelectChannelEndPoint)key.attachment();
          if (endpoint != null)           endpoint.doUpdateKey();
          continue;
        }
        Object att=key.attachment();
        if (att instanceof SelectChannelEndPoint) {
          ((SelectChannelEndPoint)att).schedule();
        }
 else         if (key.isConnectable()) {
          SocketChannel channel=(SocketChannel)key.channel();
          boolean connected=false;
          try {
            connected=channel.finishConnect();
          }
 catch (          Exception e) {
            connectionFailed(channel,e,att);
          }
 finally {
            if (connected) {
              key.interestOps(SelectionKey.OP_READ);
              SelectChannelEndPoint endpoint=createEndPoint(channel,key);
              key.attach(endpoint);
              endpoint.schedule();
            }
 else {
              key.cancel();
            }
          }
        }
 else {
          SocketChannel channel=(SocketChannel)key.channel();
          SelectChannelEndPoint endpoint=createEndPoint(channel,key);
          key.attach(endpoint);
          if (key.isReadable())           endpoint.schedule();
        }
        key=null;
      }
 catch (      CancelledKeyException e) {
        Log.ignore(e);
      }
catch (      Exception e) {
        if (isRunning())         Log.warn(e);
 else         Log.ignore(e);
        if (key != null && !(key.channel() instanceof ServerSocketChannel) && key.isValid())         key.cancel();
      }
    }
    selector.selectedKeys().clear();
    now=System.currentTimeMillis();
    _timeout.setNow(now);
    Task task=_timeout.expired();
    while (task != null) {
      if (task instanceof Runnable)       dispatch((Runnable)task);
      task=_timeout.expired();
    }
    if (now - _idleTick > __IDLE_TICK) {
      _idleTick=now;
      final long idle_now=((_lowResourcesConnections > 0 && selector.keys().size() > _lowResourcesConnections)) ? (now + _maxIdleTime - _lowResourcesMaxIdleTime) : now;
      dispatch(new Runnable(){
        public void run(){
          for (          SelectChannelEndPoint endp : _endPoints.keySet()) {
            endp.checkIdleTimestamp(idle_now);
          }
        }
      }
);
      for (      SelectionKey key : selector.keys()) {
        if (key.isValid() && key.attachment() instanceof SelectChannelEndPoint) {
          ((SelectChannelEndPoint)key.attachment()).checkKey(key);
        }
      }
    }
  }
 catch (  CancelledKeyException e) {
    Log.ignore(e);
  }
 finally {
    _selecting=null;
  }
}
