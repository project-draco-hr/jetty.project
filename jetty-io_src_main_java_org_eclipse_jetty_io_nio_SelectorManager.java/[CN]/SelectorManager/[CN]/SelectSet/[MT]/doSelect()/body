{
  try {
    _selecting=Thread.currentThread();
    List<?> changes;
    final Selector selector;
synchronized (_changes) {
      changes=_changes[_change];
      _change=_change == 0 ? 1 : 0;
      selector=_selector;
    }
    final int size=changes.size();
    for (int i=0; i < size; i++) {
      try {
        Object o=changes.get(i);
        if (o instanceof EndPoint) {
          SelectChannelEndPoint endpoint=(SelectChannelEndPoint)o;
          endpoint.doUpdateKey();
        }
 else         if (o instanceof Runnable) {
          dispatch((Runnable)o);
        }
 else         if (o instanceof ChangeSelectableChannel) {
          final ChangeSelectableChannel asc=(ChangeSelectableChannel)o;
          final SelectableChannel channel=asc._channel;
          final Object att=asc._attachment;
          if ((channel instanceof SocketChannel) && ((SocketChannel)channel).isConnected()) {
            SelectionKey key=channel.register(selector,SelectionKey.OP_READ,att);
            SelectChannelEndPoint endpoint=newEndPoint((SocketChannel)channel,this,key);
            key.attach(endpoint);
            endpoint.schedule();
          }
 else           if (channel.isOpen()) {
            channel.register(selector,SelectionKey.OP_CONNECT,att);
          }
        }
 else         if (o instanceof SocketChannel) {
          final SocketChannel channel=(SocketChannel)o;
          if (channel.isConnected()) {
            SelectionKey key=channel.register(selector,SelectionKey.OP_READ,null);
            SelectChannelEndPoint endpoint=newEndPoint(channel,this,key);
            key.attach(endpoint);
            endpoint.schedule();
          }
 else           if (channel.isOpen()) {
            channel.register(selector,SelectionKey.OP_CONNECT,null);
          }
        }
 else         if (o instanceof ServerSocketChannel) {
          ServerSocketChannel channel=(ServerSocketChannel)o;
          channel.register(getSelector(),SelectionKey.OP_ACCEPT);
        }
 else         if (o instanceof ChangeTask) {
          ((ChangeTask)o).run();
        }
 else         throw new IllegalArgumentException(o.toString());
      }
 catch (      CancelledKeyException e) {
        if (isRunning())         Log.warn(e);
 else         Log.debug(e);
      }
    }
    changes.clear();
    long idle_next;
    long retry_next;
    long now=System.currentTimeMillis();
synchronized (this) {
      _idleTimeout.setNow(now);
      _timeout.setNow(now);
      if (_lowResourcesConnections > 0 && selector.keys().size() > _lowResourcesConnections)       _idleTimeout.setDuration(_lowResourcesMaxIdleTime);
 else       _idleTimeout.setDuration(_maxIdleTime);
      idle_next=_idleTimeout.getTimeToNext();
      retry_next=_timeout.getTimeToNext();
    }
    long wait=1000L;
    if (idle_next >= 0 && wait > idle_next)     wait=idle_next;
    if (wait > 0 && retry_next >= 0 && wait > retry_next)     wait=retry_next;
    if (wait > 0) {
      if (_pausing) {
        try {
          Thread.sleep(__BUSY_PAUSE);
        }
 catch (        InterruptedException e) {
          Log.ignore(e);
        }
      }
      long before=now;
      int selected=selector.select(wait);
      now=System.currentTimeMillis();
      _idleTimeout.setNow(now);
      _timeout.setNow(now);
      _selects++;
      if (now > _monitorNext) {
        _selects=(int)(_selects * __MONITOR_PERIOD / (now - _monitorStart));
        _pausing=_selects > __MAX_SELECTS;
        if (_pausing)         _paused++;
        _selects=0;
        _jvmBug=0;
        _monitorStart=now;
        _monitorNext=now + __MONITOR_PERIOD;
      }
      if (now > _log) {
        if (_paused > 0)         Log.info(this + " Busy selector - injecting delay " + _paused+ " times");
        if (_jvmFix2 > 0)         Log.info(this + " JVM BUG(s) - injecting delay" + _jvmFix2+ " times");
        if (_jvmFix1 > 0)         Log.info(this + " JVM BUG(s) - recreating selector " + _jvmFix1+ " times, canceled keys "+ _jvmFix0+ " times");
 else         if (Log.isDebugEnabled() && _jvmFix0 > 0)         Log.info(this + " JVM BUG(s) - canceled keys " + _jvmFix0+ " times");
        _paused=0;
        _jvmFix2=0;
        _jvmFix1=0;
        _jvmFix0=0;
        _log=now + 60000;
      }
      if (selected == 0 && wait > 10 && (now - before) < (wait / 2)) {
        _jvmBug++;
        if (_jvmBug > (__JVMBUG_THRESHHOLD)) {
          try {
            if (_jvmBug == __JVMBUG_THRESHHOLD + 1)             _jvmFix2++;
            Thread.sleep(__BUSY_PAUSE);
          }
 catch (          InterruptedException e) {
            Log.ignore(e);
          }
        }
 else         if (_jvmBug == __JVMBUG_THRESHHOLD) {
synchronized (this) {
            final Selector new_selector=Selector.open();
            for (            SelectionKey k : selector.keys()) {
              if (!k.isValid() || k.interestOps() == 0)               continue;
              final SelectableChannel channel=k.channel();
              final Object attachment=k.attachment();
              if (attachment == null)               addChange(channel);
 else               addChange(channel,attachment);
            }
            _selector.close();
            _selector=new_selector;
            return;
          }
        }
 else         if (_jvmBug % 32 == 31) {
          int cancelled=0;
          for (          SelectionKey k : selector.keys()) {
            if (k.isValid() && k.interestOps() == 0) {
              k.cancel();
              cancelled++;
            }
          }
          if (cancelled > 0)           _jvmFix0++;
          return;
        }
      }
 else       if (__BUSY_KEY > 0 && selected == 1 && _selects > __MAX_SELECTS) {
        SelectionKey busy=(SelectionKey)selector.selectedKeys().iterator().next();
        if (busy == _busyKey) {
          if (++_busyKeyCount > __BUSY_KEY) {
            SelectChannelEndPoint endpoint=(SelectChannelEndPoint)busy.attachment();
            Log.warn("Busy Key " + busy + " "+ endpoint);
            busy.cancel();
            if (endpoint != null)             endpoint.close();
          }
        }
 else         _busyKeyCount=0;
        _busyKey=busy;
      }
    }
 else {
      selector.selectNow();
      _selects++;
    }
    if (_selector == null || !selector.isOpen())     return;
    for (    SelectionKey key : selector.selectedKeys()) {
      try {
        if (!key.isValid()) {
          key.cancel();
          SelectChannelEndPoint endpoint=(SelectChannelEndPoint)key.attachment();
          if (endpoint != null)           endpoint.doUpdateKey();
          continue;
        }
        Object att=key.attachment();
        if (att instanceof SelectChannelEndPoint) {
          ((SelectChannelEndPoint)att).schedule();
        }
 else         if (key.isAcceptable()) {
          SocketChannel channel=acceptChannel(key);
          if (channel == null)           continue;
          channel.configureBlocking(false);
          _nextSet=++_nextSet % _selectSet.length;
          if (_nextSet == _setID) {
            SelectionKey cKey=channel.register(_selectSet[_nextSet].getSelector(),SelectionKey.OP_READ);
            SelectChannelEndPoint endpoint=newEndPoint(channel,_selectSet[_nextSet],cKey);
            cKey.attach(endpoint);
            if (endpoint != null)             endpoint.schedule();
          }
 else {
            _selectSet[_nextSet].addChange(channel);
            _selectSet[_nextSet].wakeup();
          }
        }
 else         if (key.isConnectable()) {
          SocketChannel channel=(SocketChannel)key.channel();
          boolean connected=false;
          try {
            connected=channel.finishConnect();
          }
 catch (          Exception e) {
            connectionFailed(channel,e,att);
          }
 finally {
            if (connected) {
              key.interestOps(SelectionKey.OP_READ);
              SelectChannelEndPoint endpoint=newEndPoint(channel,this,key);
              key.attach(endpoint);
              endpoint.schedule();
            }
 else {
              key.cancel();
            }
          }
        }
 else {
          SocketChannel channel=(SocketChannel)key.channel();
          SelectChannelEndPoint endpoint=newEndPoint(channel,this,key);
          key.attach(endpoint);
          if (key.isReadable())           endpoint.schedule();
        }
        key=null;
      }
 catch (      CancelledKeyException e) {
        Log.ignore(e);
      }
catch (      Exception e) {
        if (isRunning())         Log.warn(e);
 else         Log.ignore(e);
        if (key != null && !(key.channel() instanceof ServerSocketChannel) && key.isValid())         key.cancel();
      }
    }
    selector.selectedKeys().clear();
    _idleTimeout.tick(now);
    _timeout.tick(now);
  }
 catch (  CancelledKeyException e) {
    Log.ignore(e);
  }
 finally {
    _selecting=null;
  }
}
