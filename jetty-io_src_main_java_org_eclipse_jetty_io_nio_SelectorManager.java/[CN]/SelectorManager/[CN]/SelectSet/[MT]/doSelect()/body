{
  try {
    _selecting=Thread.currentThread();
    final Selector selector=_selector;
    if (selector == null)     return;
    Object change;
    int changes=_changes.size();
    while (changes-- > 0 && (change=_changes.poll()) != null) {
      Channel ch=null;
      SelectionKey key=null;
      try {
        if (change instanceof EndPoint) {
          SelectChannelEndPoint endpoint=(SelectChannelEndPoint)change;
          ch=endpoint.getChannel();
          endpoint.doUpdateKey();
        }
 else         if (change instanceof ChannelAndAttachment) {
          final ChannelAndAttachment asc=(ChannelAndAttachment)change;
          final SelectableChannel channel=asc._channel;
          ch=channel;
          final Object att=asc._attachment;
          if ((channel instanceof SocketChannel) && ((SocketChannel)channel).isConnected()) {
            key=channel.register(selector,SelectionKey.OP_READ,att);
            SelectChannelEndPoint endpoint=createEndPoint((SocketChannel)channel,key);
            key.attach(endpoint);
            endpoint.schedule();
          }
 else           if (channel.isOpen()) {
            key=channel.register(selector,SelectionKey.OP_CONNECT,att);
          }
        }
 else         if (change instanceof SocketChannel) {
          final SocketChannel channel=(SocketChannel)change;
          ch=channel;
          key=channel.register(selector,SelectionKey.OP_READ,null);
          SelectChannelEndPoint endpoint=createEndPoint(channel,key);
          key.attach(endpoint);
          endpoint.schedule();
        }
 else         if (change instanceof ChangeTask) {
          ((Runnable)change).run();
        }
 else         if (change instanceof Runnable) {
          dispatch((Runnable)change);
        }
 else         throw new IllegalArgumentException(change.toString());
      }
 catch (      CancelledKeyException e) {
        LOG.ignore(e);
      }
catch (      ThreadDeath e) {
        throw e;
      }
catch (      Throwable e) {
        if (isRunning())         LOG.warn(e);
 else         LOG.debug(e);
        try {
          if (ch != null)           ch.close();
        }
 catch (        IOException e2) {
          LOG.debug(e2);
        }
      }
    }
    int selected=selector.selectNow();
    long now=System.currentTimeMillis();
    if (selected == 0 && selector.selectedKeys().isEmpty()) {
      if (_pausing) {
        try {
          Thread.sleep(__BUSY_PAUSE);
        }
 catch (        InterruptedException e) {
          LOG.ignore(e);
        }
        now=System.currentTimeMillis();
      }
      _timeout.setNow(now);
      long to_next_timeout=_timeout.getTimeToNext();
      long wait=_changes.size() == 0 ? __IDLE_TICK : 0L;
      if (wait > 0 && to_next_timeout >= 0 && wait > to_next_timeout)       wait=to_next_timeout;
      if (wait > 0) {
        long before=now;
        selected=selector.select(wait);
        now=System.currentTimeMillis();
        _timeout.setNow(now);
        if (__MONITOR_PERIOD > 0 && now - before <= 1) {
          if (++_busySelects > __MAX_SELECTS) {
            _pausing=true;
            if (!_paused) {
              _paused=true;
              LOG.warn("Selector {} is too busy, pausing!",this);
              final SelectSet set=this;
              SelectorManager.this.dispatch(new Runnable(){
                public void run(){
                  System.err.println(set + ":\n" + set.dump());
                }
                public String toString(){
                  return "Dump-" + super.toString();
                }
              }
);
            }
          }
        }
      }
    }
    if (_selector == null || !selector.isOpen())     return;
    for (    SelectionKey key : selector.selectedKeys()) {
      SocketChannel channel=null;
      try {
        if (!key.isValid()) {
          key.cancel();
          SelectChannelEndPoint endpoint=(SelectChannelEndPoint)key.attachment();
          if (endpoint != null)           endpoint.doUpdateKey();
          continue;
        }
        Object att=key.attachment();
        if (att instanceof SelectChannelEndPoint) {
          if (key.isReadable() || key.isWritable())           ((SelectChannelEndPoint)att).schedule();
        }
 else         if (key.isConnectable()) {
          channel=(SocketChannel)key.channel();
          boolean connected=false;
          try {
            connected=channel.finishConnect();
          }
 catch (          Exception e) {
            connectionFailed(channel,e,att);
          }
 finally {
            if (connected) {
              key.interestOps(SelectionKey.OP_READ);
              SelectChannelEndPoint endpoint=createEndPoint(channel,key);
              key.attach(endpoint);
              endpoint.schedule();
            }
 else {
              key.cancel();
            }
          }
        }
 else {
          channel=(SocketChannel)key.channel();
          SelectChannelEndPoint endpoint=createEndPoint(channel,key);
          key.attach(endpoint);
          if (key.isReadable())           endpoint.schedule();
        }
        key=null;
      }
 catch (      CancelledKeyException e) {
        LOG.ignore(e);
      }
catch (      Exception e) {
        if (isRunning())         LOG.warn(e);
 else         LOG.ignore(e);
        try {
          if (channel != null)           channel.close();
        }
 catch (        IOException e2) {
          LOG.debug(e2);
        }
        if (key != null && !(key.channel() instanceof ServerSocketChannel) && key.isValid())         key.cancel();
      }
    }
    selector.selectedKeys().clear();
    now=System.currentTimeMillis();
    _timeout.setNow(now);
    Task task=_timeout.expired();
    while (task != null) {
      if (task instanceof Runnable)       dispatch((Runnable)task);
      task=_timeout.expired();
    }
    if (now - _idleTick > __IDLE_TICK) {
      _idleTick=now;
      final long idle_now=((_lowResourcesConnections > 0 && selector.keys().size() > _lowResourcesConnections)) ? (now + _maxIdleTime - _lowResourcesMaxIdleTime) : now;
      dispatch(new Runnable(){
        public void run(){
          for (          SelectChannelEndPoint endp : _endPoints.keySet()) {
            endp.checkIdleTimestamp(idle_now);
          }
        }
        public String toString(){
          return "Idle-" + super.toString();
        }
      }
);
    }
    if (__MONITOR_PERIOD > 0 && now > _monitorNext) {
      _busySelects=0;
      _pausing=false;
      _monitorNext=now + __MONITOR_PERIOD;
    }
  }
 catch (  ClosedSelectorException e) {
    if (isRunning())     LOG.warn(e);
 else     LOG.ignore(e);
  }
catch (  CancelledKeyException e) {
    LOG.ignore(e);
  }
 finally {
    _selecting=null;
  }
}
