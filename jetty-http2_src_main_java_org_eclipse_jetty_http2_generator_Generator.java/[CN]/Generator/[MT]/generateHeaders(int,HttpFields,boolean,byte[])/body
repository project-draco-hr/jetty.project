{
  if (streamId < 0)   throw new IllegalArgumentException("Invalid stream id: " + streamId);
  int paddingLength=paddingBytes == null ? 0 : paddingBytes.length;
  if (paddingLength > Frame.MAX_LENGTH - 3)   throw new IllegalArgumentException("Invalid padding length: " + paddingLength);
  int extraPaddingBytes=paddingLength > 0xFF ? 2 : paddingLength > 0 ? 1 : 0;
  ByteBufferPool.Lease hpackBuffers=encoder.encode(headers);
  long hpackLength=hpackBuffers.getTotalLength();
  long length=extraPaddingBytes + hpackLength + paddingLength;
  if (length > Frame.MAX_LENGTH)   throw new IllegalArgumentException("Invalid headers, too big");
  int flags=Flag.END_HEADERS;
  if (!contentFollows)   flags|=Flag.END_STREAM;
  if (extraPaddingBytes > 0)   flags|=Flag.PADDING_LOW;
  if (extraPaddingBytes > 1)   flags|=Flag.PADDING_HIGH;
  ByteBuffer header=generateHeader(FrameType.HEADERS,Frame.HEADER_LENGTH + extraPaddingBytes,(int)length,flags,streamId);
  if (extraPaddingBytes == 2)   header.putShort((short)paddingLength);
 else   if (extraPaddingBytes == 1)   header.put((byte)paddingLength);
  ByteBufferPool.Lease lease=new ByteBufferPool.Lease(byteBufferPool);
  BufferUtil.flipToFlush(header,0);
  lease.add(header,true);
  lease.merge(hpackBuffers);
  if (paddingBytes != null) {
    lease.add(ByteBuffer.wrap(paddingBytes),false);
  }
  return lease;
}
