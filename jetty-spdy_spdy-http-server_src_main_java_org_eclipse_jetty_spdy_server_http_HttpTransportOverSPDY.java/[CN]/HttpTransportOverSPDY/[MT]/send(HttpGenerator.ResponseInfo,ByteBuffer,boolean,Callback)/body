{
  if (LOG.isDebugEnabled())   LOG.debug("Sending {} {} {} {} last={}",this,stream,info,BufferUtil.toDetailString(content),lastContent);
  if (stream.isClosed() || stream.isReset()) {
    EofException exception=new EofException("stream closed");
    callback.failed(exception);
    return;
  }
  boolean isHeadRequest=HttpMethod.HEAD.name().equalsIgnoreCase(requestHeaders.get(HTTPSPDYHeader.METHOD.name(version)).getValue());
  boolean hasContent=BufferUtil.hasContent(content) && !isHeadRequest;
  boolean close=!hasContent && lastContent;
  if (info != null) {
    if (!committed.compareAndSet(false,true)) {
      StreamException exception=new StreamException(stream.getId(),StreamStatus.PROTOCOL_ERROR,"Stream already committed!");
      callback.failed(exception);
      LOG.debug("Committed response twice.",exception);
      return;
    }
    sendReply(info,!hasContent ? callback : new Callback.Adapter(){
      @Override public void failed(      Throwable x){
        callback.failed(x);
      }
    }
,close);
  }
  if (hasContent) {
    LOG.debug("Send content: {} on stream: {} lastContent={}",BufferUtil.toDetailString(content),stream,lastContent);
    stream.data(new ByteBufferDataInfo(endPoint.getIdleTimeout(),TimeUnit.MILLISECONDS,content,lastContent),callback);
  }
 else   if (lastContent && info == null) {
    LOG.debug("No content and lastContent=true. Sending empty ByteBuffer to close stream: {}",stream);
    stream.data(new ByteBufferDataInfo(endPoint.getIdleTimeout(),TimeUnit.MILLISECONDS,BufferUtil.EMPTY_BUFFER,lastContent),callback);
  }
 else   if (!lastContent && !hasContent && info == null)   throw new IllegalStateException("not lastContent, no content and no responseInfo!");
}
