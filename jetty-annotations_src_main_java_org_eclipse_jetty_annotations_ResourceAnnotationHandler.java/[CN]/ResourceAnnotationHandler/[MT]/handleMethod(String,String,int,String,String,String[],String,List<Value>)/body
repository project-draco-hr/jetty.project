{
  InjectionCollection injections=(InjectionCollection)_wac.getAttribute(InjectionCollection.INJECTION_COLLECTION);
  Class clazz=null;
  try {
    clazz=Loader.loadClass(null,className);
    Class[] args=Util.convertTypes(params);
    Method m=clazz.getDeclaredMethod(methodName,args);
    if (!Util.isServletType(m.getDeclaringClass())) {
      Log.debug("Ignoring @Resource annotation on on-servlet type method " + m.getName());
      return;
    }
    Resource resource=(Resource)m.getAnnotation(Resource.class);
    if (resource == null)     return;
    if (Modifier.isStatic(m.getModifiers()))     throw new IllegalStateException(m + " cannot be static");
    if (!IntrospectionUtil.isJavaBeanCompliantSetter(m))     throw new IllegalStateException(m + " is not a java bean compliant setter method");
    String name=m.getName().substring(3);
    name=name.substring(0,1).toLowerCase() + name.substring(1);
    name=m.getDeclaringClass().getCanonicalName() + "/" + name;
    name=(resource.name() != null && !resource.name().trim().equals("") ? resource.name() : name);
    String mappedName=(resource.mappedName() != null && !resource.mappedName().trim().equals("") ? resource.mappedName() : null);
    Class type=m.getParameterTypes()[0];
    Resource.AuthenticationType auth=resource.authenticationType();
    boolean shareable=resource.shareable();
    if ((resource.type() != null) && !resource.type().equals(Object.class) && (!IntrospectionUtil.isTypeCompatible(type,resource.type(),false)))     throw new IllegalStateException("@Resource incompatible type=" + resource.type() + " with method param="+ type+ " for "+ m);
    Injection webXmlInjection=injections.getInjection(m.getDeclaringClass(),m);
    if (webXmlInjection == null) {
      try {
        boolean bound=org.eclipse.jetty.plus.jndi.NamingEntryUtil.bindToENC(_wac,name,mappedName);
        if (!bound)         bound=org.eclipse.jetty.plus.jndi.NamingEntryUtil.bindToENC(_wac.getServer(),name,mappedName);
        if (!bound)         bound=org.eclipse.jetty.plus.jndi.NamingEntryUtil.bindToENC(null,name,mappedName);
        if (!bound) {
          try {
            InitialContext ic=new InitialContext();
            String nameInEnvironment=(mappedName != null ? mappedName : name);
            ic.lookup("java:comp/env/" + nameInEnvironment);
            bound=true;
          }
 catch (          NameNotFoundException e) {
            bound=false;
          }
        }
        if (bound) {
          Log.debug("Bound " + (mappedName == null ? name : mappedName) + " as "+ name);
          Injection injection=new Injection();
          injection.setTargetClass(m.getDeclaringClass());
          injection.setJndiName(name);
          injection.setMappingName(mappedName);
          injection.setTarget(m);
          injections.add(injection);
        }
 else         if (!Util.isEnvEntryType(type)) {
          throw new IllegalStateException("No resource at " + (mappedName == null ? name : mappedName));
        }
      }
 catch (      NamingException e) {
        if (!Util.isEnvEntryType(type))         throw new IllegalStateException(e);
      }
    }
 else {
      Object value=webXmlInjection.lookupInjectedValue();
      if (!IntrospectionUtil.isTypeCompatible(type,value.getClass(),false))       throw new IllegalStateException("Type of field=" + type + " is not compatible with Resource type="+ value.getClass());
    }
  }
 catch (  Exception e) {
    Log.warn(e);
  }
}
