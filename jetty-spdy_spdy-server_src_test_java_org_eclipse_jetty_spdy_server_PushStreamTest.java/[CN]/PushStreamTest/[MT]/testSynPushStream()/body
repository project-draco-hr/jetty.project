{
  final AtomicReference<Stream> pushStreamRef=new AtomicReference<>();
  final CountDownLatch pushStreamLatch=new CountDownLatch(1);
  Session clientSession=startClient(startServer(new ServerSessionFrameListener.Adapter(){
    @Override public StreamFrameListener onSyn(    Stream stream,    SynInfo synInfo){
      stream.reply(new ReplyInfo(false),new Callback.Adapter());
      stream.push(new PushInfo(new Fields(),true),new Promise.Adapter<Stream>());
      return null;
    }
  }
),null);
  Stream stream=clientSession.syn(new SynInfo(new Fields(),true),new StreamFrameListener.Adapter(){
    @Override public StreamFrameListener onPush(    Stream stream,    PushInfo pushInfo){
      assertThat("streamId is even",stream.getId() % 2,is(0));
      assertThat("stream is unidirectional",stream.isUnidirectional(),is(true));
      assertThat("stream is closed",stream.isClosed(),is(true));
      assertThat("stream has associated stream",stream.getAssociatedStream(),notNullValue());
      try {
        stream.reply(new ReplyInfo(false),new Callback.Adapter());
        fail("Cannot reply to push streams");
      }
 catch (      IllegalStateException x) {
      }
      pushStreamRef.set(stream);
      pushStreamLatch.countDown();
      return null;
    }
  }
);
  assertThat("onSyn has been called",pushStreamLatch.await(5,TimeUnit.SECONDS),is(true));
  Stream pushStream=pushStreamRef.get();
  assertThat("main stream and associated stream are the same",stream,sameInstance(pushStream.getAssociatedStream()));
}
