{
  final HttpChannel last=setCurrentHttpChannel(this);
  String threadName=null;
  if (LOG.isDebugEnabled()) {
    threadName=Thread.currentThread().getName();
    Thread.currentThread().setName(threadName + " - " + _request.getHttpURI());
    LOG.debug("{} handle enter",this);
  }
  HttpChannelState.Action action=_state.handling();
  try {
    loop:     while (action.ordinal() < HttpChannelState.Action.WAIT.ordinal() && getServer().isRunning()) {
      boolean error=false;
      try {
        if (LOG.isDebugEnabled())         LOG.debug("{} action {}",this,action);
switch (action) {
case REQUEST_DISPATCH:
          _request.setHandled(false);
        _response.getHttpOutput().reopen();
      _request.setDispatcherType(DispatcherType.REQUEST);
    List<HttpConfiguration.Customizer> customizers=_configuration.getCustomizers();
  if (!customizers.isEmpty()) {
    for (    HttpConfiguration.Customizer customizer : customizers)     customizer.customize(getConnector(),_configuration,_request);
  }
getServer().handle(this);
break;
case ASYNC_DISPATCH:
_request.setHandled(false);
_response.getHttpOutput().reopen();
_request.setDispatcherType(DispatcherType.ASYNC);
getServer().handleAsync(this);
break;
case ASYNC_EXPIRED:
_request.setHandled(false);
_response.getHttpOutput().reopen();
_request.setDispatcherType(DispatcherType.ERROR);
Throwable ex=_state.getAsyncContextEvent().getThrowable();
String reason="Async Timeout";
if (ex != null) {
reason="Async Exception";
_request.setAttribute(RequestDispatcher.ERROR_EXCEPTION,ex);
}
_request.setAttribute(RequestDispatcher.ERROR_STATUS_CODE,new Integer(500));
_request.setAttribute(RequestDispatcher.ERROR_MESSAGE,reason);
_request.setAttribute(RequestDispatcher.ERROR_REQUEST_URI,_request.getRequestURI());
_response.setStatusWithReason(500,reason);
ErrorHandler eh=ErrorHandler.getErrorHandler(getServer(),_state.getContextHandler());
if (eh instanceof ErrorHandler.ErrorPageMapper) {
String error_page=((ErrorHandler.ErrorPageMapper)eh).getErrorPage((HttpServletRequest)_state.getAsyncContextEvent().getSuppliedRequest());
if (error_page != null) _state.getAsyncContextEvent().setDispatchPath(error_page);
}
getServer().handleAsync(this);
break;
case READ_CALLBACK:
{
ContextHandler handler=_state.getContextHandler();
if (handler != null) handler.handle(_request.getHttpInput());
 else _request.getHttpInput().run();
break;
}
case WRITE_CALLBACK:
{
ContextHandler handler=_state.getContextHandler();
if (handler != null) handler.handle(_response.getHttpOutput());
 else _response.getHttpOutput().run();
break;
}
default :
break loop;
}
}
 catch (Error e) {
if ("ContinuationThrowable".equals(e.getClass().getSimpleName())) LOG.ignore(e);
 else {
error=true;
LOG.warn(String.valueOf(_uri),e);
_state.error(e);
_request.setHandled(true);
handleException(e);
}
}
catch (Exception e) {
error=true;
if (e instanceof EofException) LOG.debug(e);
 else LOG.warn(String.valueOf(_request.getHttpURI()),e);
_state.error(e);
_request.setHandled(true);
handleException(e);
}
 finally {
if (error && _state.isAsyncStarted()) _state.errorComplete();
action=_state.unhandle();
}
}
}
  finally {
setCurrentHttpChannel(last);
if (threadName != null && LOG.isDebugEnabled()) Thread.currentThread().setName(threadName);
}
if (action == Action.COMPLETE) {
try {
_state.completed();
if (!_response.isCommitted() && !_request.isHandled()) {
_response.sendError(404);
}
 else {
_response.closeOutput();
}
}
 catch (EofException|ClosedChannelException e) {
LOG.debug(e);
}
catch (Exception e) {
LOG.warn("complete failed",e);
}
 finally {
_request.setHandled(true);
_transport.completed();
}
}
if (LOG.isDebugEnabled()) LOG.debug("{} handle exit, result {}",this,action);
return action != Action.WAIT;
}
