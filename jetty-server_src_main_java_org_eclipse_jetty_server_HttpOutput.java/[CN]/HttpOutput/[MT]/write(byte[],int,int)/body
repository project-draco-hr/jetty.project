{
  _written+=len;
  boolean complete=_channel.getResponse().isAllContentWritten(_written);
  while (true) {
switch (_state.get()) {
case OPEN:
      break;
case ASYNC:
    throw new IllegalStateException("isReady() not called");
case READY:
  if (!_state.compareAndSet(OutputState.READY,OutputState.PENDING))   continue;
if (!complete && len <= _commitSize) {
  if (_aggregate == null)   _aggregate=_channel.getByteBufferPool().acquire(getBufferSize(),false);
  int filled=BufferUtil.fill(_aggregate,b,off,len);
  if (filled == len && !BufferUtil.isFull(_aggregate)) {
    if (!_state.compareAndSet(OutputState.PENDING,OutputState.ASYNC))     throw new IllegalStateException();
    return;
  }
  off+=filled;
  len-=filled;
}
new AsyncWrite(b,off,len,complete).iterate();
return;
case PENDING:
case UNREADY:
throw new WritePendingException();
case CLOSED:
throw new EofException("Closed");
}
break;
}
int capacity=getBufferSize();
if (!complete && len <= _commitSize) {
if (_aggregate == null) _aggregate=_channel.getByteBufferPool().acquire(capacity,false);
int filled=BufferUtil.fill(_aggregate,b,off,len);
if (filled == len && !BufferUtil.isFull(_aggregate)) return;
off+=filled;
len-=filled;
}
if (BufferUtil.hasContent(_aggregate)) {
_channel.write(_aggregate,complete && len == 0);
if (len > 0 && !complete && len <= _commitSize) {
BufferUtil.append(_aggregate,b,off,len);
return;
}
}
if (len > 0) {
ByteBuffer wrap=ByteBuffer.wrap(b,off,len);
ByteBuffer readonly=wrap.asReadOnlyBuffer();
while (len > getBufferSize()) {
int p=readonly.position();
int l=p + getBufferSize();
readonly.limit(p + getBufferSize());
_channel.write(readonly,false);
len-=getBufferSize();
readonly.limit(l + Math.min(len,getBufferSize()));
readonly.position(l);
}
_channel.write(readonly,complete);
}
 else if (complete) _channel.write(BufferUtil.EMPTY_BUFFER,complete);
if (complete) closed();
}
