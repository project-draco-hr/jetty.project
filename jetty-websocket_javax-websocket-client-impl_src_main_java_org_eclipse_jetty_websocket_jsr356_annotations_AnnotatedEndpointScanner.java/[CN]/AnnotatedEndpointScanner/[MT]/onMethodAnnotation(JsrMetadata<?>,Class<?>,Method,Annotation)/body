{
  LOG.debug("onMethodAnnotation({}, {}, {}, {})",metadata,pojo,method,annotation);
  if (isAnnotation(annotation,OnOpen.class)) {
    assertIsPublicNonStatic(method);
    assertIsReturn(method,Void.TYPE);
    metadata.onOpen=establishCallable(metadata,pojo,method,paramsOnOpen,OnOpen.class);
    return;
  }
  if (isAnnotation(annotation,OnClose.class)) {
    assertIsPublicNonStatic(method);
    assertIsReturn(method,Void.TYPE);
    metadata.onClose=establishCallable(metadata,pojo,method,paramsOnClose,OnClose.class);
    return;
  }
  if (isAnnotation(annotation,OnError.class)) {
    assertIsPublicNonStatic(method);
    assertIsReturn(method,Void.TYPE);
    metadata.onError=establishCallable(metadata,pojo,method,paramsOnError,OnError.class);
    return;
  }
  if (isAnnotation(annotation,OnMessage.class)) {
    assertIsPublicNonStatic(method);
    assertIsReturn(method,Void.TYPE);
    ParameterizedMethod msgMethod=establishCallable(metadata,pojo,method,paramsOnMessage,OnMessage.class);
switch (msgMethod.getMessageType()) {
case TEXT:
      metadata.onText=msgMethod;
    break;
case BINARY:
  metadata.onBinary=msgMethod;
break;
case PONG:
metadata.onPong=msgMethod;
break;
default :
StringBuilder err=new StringBuilder();
err.append("Invalid @OnMessage method signature,");
err.append(" Missing type TEXT, BINARY, or PONG parameter: ");
err.append(msgMethod.getFullyQualifiedMethodName());
throw new InvalidSignatureException(err.toString());
}
}
}
