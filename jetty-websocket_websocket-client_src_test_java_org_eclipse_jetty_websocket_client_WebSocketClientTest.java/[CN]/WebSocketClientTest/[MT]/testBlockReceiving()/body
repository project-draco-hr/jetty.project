{
  WebSocketClientFactory factory=new WebSocketClientFactory();
  WebSocketClient client=factory.newWebSocketClient();
  client.getPolicy().setIdleTimeout(60000);
  final AtomicBoolean open=new AtomicBoolean(false);
  final AtomicInteger close=new AtomicInteger();
  final CountDownLatch _latch=new CountDownLatch(1);
  final StringBuilder closeMessage=new StringBuilder();
  final Exchanger<String> exchanger=new Exchanger<String>();
  WebSocketListener socket=new WebSocketAdapter(){
    @Override public void onWebSocketClose(    int statusCode,    String reason){
      close.set(statusCode);
      closeMessage.append(reason);
      _latch.countDown();
    }
    @Override public void onWebSocketConnect(    WebSocketConnection connection){
      open.set(true);
    }
    @Override public void onWebSocketText(    String message){
      try {
        exchanger.exchange(message);
      }
 catch (      InterruptedException e) {
      }
    }
  }
;
  URI wsUri=new URI("ws://127.0.0.1:" + server.getPort() + "/");
  Future<WebSocketConnection> future=client.connect(wsUri,socket);
  ServerConnection sconnection=server.accept();
  sconnection.setSoTimeout(60000);
  WebSocketConnection connection=future.get(250,TimeUnit.MILLISECONDS);
  Assert.assertNotNull(connection);
  Assert.assertTrue(open.get());
  Assert.assertEquals(0,close.get());
  byte[] send=new byte[]{(byte)0x81,(byte)0x05,(byte)'H',(byte)'e',(byte)'l',(byte)'l',(byte)'o'};
  final int messages=100000;
  final AtomicInteger m=new AtomicInteger();
  Thread consumer=new Thread(){
    @Override public void run(){
      try {
        Thread.sleep(200);
        while (m.get() < messages) {
          String msg=exchanger.exchange(null);
          if ("Hello".equals(msg)) {
            m.incrementAndGet();
          }
 else {
            throw new IllegalStateException("exchanged " + msg);
          }
          if ((m.get() % 1000) == 0) {
            Thread.sleep(10);
          }
        }
      }
 catch (      InterruptedException e) {
        return;
      }
catch (      Exception e) {
        e.printStackTrace();
      }
    }
  }
;
  consumer.start();
  long start=System.currentTimeMillis();
  for (int i=0; i < messages; i++) {
    sconnection.write(send,0,send.length);
    sconnection.flush();
  }
  while (consumer.isAlive()) {
    Thread.sleep(10);
  }
  long readDur=(System.currentTimeMillis() - start);
  Assert.assertThat("read duration",readDur,greaterThan(1000L));
  Assert.assertEquals(m.get(),messages);
  start=System.currentTimeMillis();
  sconnection.write(new byte[]{(byte)0x88,(byte)0x02,(byte)4,(byte)87},0,4);
  sconnection.flush();
  _latch.await(10,TimeUnit.SECONDS);
  Assert.assertTrue((System.currentTimeMillis() - start) < 5000);
  Assert.assertEquals(1002,close.get());
  Assert.assertEquals("Invalid close code 1111",closeMessage.toString());
}
