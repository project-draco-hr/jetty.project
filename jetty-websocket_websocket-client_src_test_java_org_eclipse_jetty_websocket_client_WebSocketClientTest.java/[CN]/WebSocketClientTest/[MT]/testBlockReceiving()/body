{
  final Exchanger<String> exchanger=new Exchanger<String>();
  TrackingSocket tsocket=new TrackingSocket();
  tsocket.messageExchanger=exchanger;
  WebSocketClient client=factory.newWebSocketClient(tsocket);
  client.getPolicy().setIdleTimeout(60000);
  URI wsUri=server.getWsUri();
  Future<UpgradeResponse> future=client.connect(wsUri);
  ServerConnection sconnection=server.accept();
  sconnection.setSoTimeout(60000);
  sconnection.upgrade();
  future.get(500,TimeUnit.MILLISECONDS);
  byte[] send=new byte[]{(byte)0x81,(byte)0x05,(byte)'H',(byte)'e',(byte)'l',(byte)'l',(byte)'o'};
  final int messages=100000;
  final AtomicInteger m=new AtomicInteger();
  Thread consumer=new Thread(){
    @Override public void run(){
      try {
        Thread.sleep(200);
        while (m.get() < messages) {
          String msg=exchanger.exchange(null);
          if ("Hello".equals(msg)) {
            m.incrementAndGet();
          }
 else {
            throw new IllegalStateException("exchanged " + msg);
          }
          if ((m.get() % 1000) == 0) {
            Thread.sleep(10);
          }
        }
      }
 catch (      InterruptedException e) {
        return;
      }
catch (      Exception e) {
        e.printStackTrace();
      }
    }
  }
;
  consumer.start();
  long start=System.currentTimeMillis();
  for (int i=0; i < messages; i++) {
    sconnection.write(send,0,send.length);
    sconnection.flush();
  }
  while (consumer.isAlive()) {
    Thread.sleep(10);
  }
  long readDur=(System.currentTimeMillis() - start);
  Assert.assertThat("read duration",readDur,greaterThan(1000L));
  Assert.assertEquals(m.get(),messages);
  sconnection.close(StatusCode.NORMAL);
  Assert.assertTrue("Client Socket Closed",tsocket.closeLatch.await(10,TimeUnit.SECONDS));
  tsocket.assertCloseCode(StatusCode.NORMAL);
}
