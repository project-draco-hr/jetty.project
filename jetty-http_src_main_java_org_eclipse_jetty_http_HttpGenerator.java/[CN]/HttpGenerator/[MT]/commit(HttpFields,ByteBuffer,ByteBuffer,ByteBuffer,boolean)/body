{
  if (isResponse() && _status == 0)   throw new EofException();
  int pos=header.position();
  try {
    BufferUtil.flipToFill(header);
switch (_state) {
case START:
case COMPLETING_UNCOMMITTED:
      if (isRequest()) {
        if (_version == HttpVersion.HTTP_0_9) {
          _noContent=true;
          generateRequestLine(header);
          _state=State.END;
          return Result.OK;
        }
        _persistent=true;
        generateRequestLine(header);
      }
 else {
        if (_version == HttpVersion.HTTP_0_9) {
          _persistent=false;
          _contentLength=HttpTokens.EOF_CONTENT;
          _state=State.COMMITTED;
          return prepareContent(null,buffer,content);
        }
        if (_persistent == null)         _persistent=(_version.ordinal() > HttpVersion.HTTP_1_0.ordinal());
        generateResponseLine(header);
        if (_status >= 100 && _status < 200) {
          _noContent=true;
          if (_status != 101) {
            header.put(HttpTokens.CRLF);
            _state=State.START;
            return Result.OK;
          }
        }
 else         if (_status == 204 || _status == 304) {
          _noContent=true;
        }
      }
    generateHeaders(fields,header,content,last);
  _state=_state == State.COMPLETING_UNCOMMITTED ? State.COMMITTING_COMPLETING : State.COMMITTING;
case COMMITTING:
case COMMITTING_COMPLETING:
if (BufferUtil.hasContent(content)) {
  if (_contentLength > 0 && content.remaining() > (_contentLength - _contentPrepared)) {
    LOG.warn("Content truncated at {}",new Throwable());
    content.limit(content.position() + (int)(_contentLength - _contentPrepared));
  }
  if (BufferUtil.isEmpty(buffer) && content.remaining() > _largeContent) {
    _contentPrepared+=content.remaining();
    if (isChunking())     prepareChunk(header,content.remaining());
    return Result.FLUSH_CONTENT;
  }
  if (buffer == null)   return Result.NEED_BUFFER;
  _contentPrepared+=BufferUtil.put(content,buffer);
  if (isChunking())   prepareChunk(header,buffer.remaining());
  return Result.FLUSH;
}
_state=_state == State.COMMITTING ? State.COMMITTED : State.COMPLETING;
break;
default :
throw new IllegalStateException(this.toString());
}
}
 catch (BufferOverflowException e) {
throw new RuntimeException("Header>" + header.capacity(),e);
}
 finally {
BufferUtil.flipToFlush(header,pos);
}
return _state == State.COMPLETING ? Result.NEED_COMPLETE : Result.OK;
}
