{
  Result result=Result.OK;
  if (_state == State.END)   return result;
  if (action == null)   action=Action.PREPARE;
  if (BufferUtil.hasContent(content)) {
    if (_content == EndOfContent.CONTENT_LENGTH && info != null && info.getContentLength() >= 0 && content.remaining() > (info.getContentLength() - _contentPrepared)) {
      LOG.warn("Content truncated. Info.getContentLength()==" + info.getContentLength() + " prepared="+ _contentPrepared+ " content="+ content.remaining(),new Throwable());
      content.limit(content.position() + (int)(info.getContentLength() - _contentPrepared));
    }
    if (BufferUtil.isEmpty(buffer) && content.remaining() > _largeContent) {
      if (isCommitted()) {
        if (isChunking()) {
          if (chunk == null)           return Result.NEED_CHUNK;
          BufferUtil.clearToFill(chunk);
          prepareChunk(chunk,content.remaining());
          BufferUtil.flipToFlush(chunk,0);
        }
        _contentPrepared+=content.remaining();
        return Result.FLUSH_CONTENT;
      }
      _state=action == Action.COMPLETE ? State.COMMITTING_COMPLETING : State.COMMITTING;
      result=Result.FLUSH_CONTENT;
    }
 else {
      if (buffer == null)       return Result.NEED_BUFFER;
      _contentPrepared+=BufferUtil.append(content,buffer);
      if (BufferUtil.isFull(buffer)) {
        if (isCommitted()) {
          if (isChunking()) {
            if (chunk == null)             return Result.NEED_CHUNK;
            BufferUtil.clearToFill(chunk);
            prepareChunk(chunk,buffer.remaining());
            BufferUtil.flipToFlush(chunk,0);
          }
          return Result.FLUSH;
        }
        _state=action == Action.COMPLETE ? State.COMMITTING_COMPLETING : State.COMMITTING;
        result=Result.FLUSH;
      }
    }
  }
  if (result == Result.OK) {
switch (action) {
case COMPLETE:
      if (!isCommitted())       _state=State.COMMITTING_COMPLETING;
 else       if (_state == State.COMMITTED)       _state=State.COMPLETING;
    result=BufferUtil.hasContent(buffer) ? Result.FLUSH : Result.OK;
  break;
case FLUSH:
if (!isCommitted()) _state=State.COMMITTING;
result=BufferUtil.hasContent(buffer) ? Result.FLUSH : Result.OK;
break;
}
}
final int pos=header == null ? -1 : BufferUtil.flipToFill(header);
try {
switch (_state) {
case START:
return Result.OK;
case COMMITTING:
case COMMITTING_COMPLETING:
{
if (info == null) return Result.NEED_INFO;
if (info instanceof RequestInfo) {
if (header == null || header.capacity() <= CHUNK_SIZE) return Result.NEED_HEADER;
if (info.getHttpVersion() == HttpVersion.HTTP_0_9) {
_noContent=true;
generateRequestLine((RequestInfo)info,header);
_state=State.END;
return Result.OK;
}
_persistent=true;
generateRequestLine((RequestInfo)info,header);
}
 else {
if (info.getHttpVersion() == HttpVersion.HTTP_0_9) {
_persistent=false;
_content=EndOfContent.EOF_CONTENT;
_state=State.COMMITTED;
if (result == Result.FLUSH_CONTENT) _contentPrepared+=content.remaining();
return result;
}
if (header == null || header.capacity() <= CHUNK_SIZE) return Result.NEED_HEADER;
if (_persistent == null) _persistent=(info.getHttpVersion().ordinal() > HttpVersion.HTTP_1_0.ordinal());
generateResponseLine(((ResponseInfo)info),header);
int status=((ResponseInfo)info).getStatus();
if (status >= 100 && status < 200) {
_noContent=true;
if (status != 101) {
header.put(HttpTokens.CRLF);
_state=State.COMPLETING_1XX;
return Result.FLUSH;
}
}
 else if (status == 204 || status == 304) {
_noContent=true;
}
}
boolean completing=action == Action.COMPLETE || _state == State.COMMITTING_COMPLETING;
generateHeaders(info,header,content,completing);
_state=completing ? State.COMPLETING : State.COMMITTED;
switch (result) {
case FLUSH:
if (isChunking()) prepareChunk(header,buffer.remaining());
break;
case FLUSH_CONTENT:
if (isChunking()) prepareChunk(header,content.remaining());
_contentPrepared+=content.remaining();
break;
case OK:
if (BufferUtil.hasContent(buffer)) {
if (isChunking()) prepareChunk(header,buffer.remaining());
}
result=Result.FLUSH;
}
return result;
}
case COMMITTED:
return Result.OK;
case COMPLETING:
if (isChunking()) {
if (chunk == null) return Result.NEED_CHUNK;
BufferUtil.clearToFill(chunk);
switch (result) {
case FLUSH:
prepareChunk(chunk,buffer.remaining());
break;
case FLUSH_CONTENT:
prepareChunk(chunk,content.remaining());
break;
case OK:
if (BufferUtil.hasContent(buffer)) {
result=Result.FLUSH;
prepareChunk(chunk,buffer.remaining());
}
 else {
result=Result.FLUSH;
_state=State.END;
prepareChunk(chunk,0);
}
}
BufferUtil.flipToFlush(chunk,0);
}
 else if (result == Result.OK) {
if (BufferUtil.hasContent(buffer)) result=Result.FLUSH;
 else {
if (!Boolean.TRUE.equals(_persistent)) result=Result.SHUTDOWN_OUT;
_state=State.END;
}
}
return result;
case COMPLETING_1XX:
reset();
return Result.OK;
case END:
if (!Boolean.TRUE.equals(_persistent)) result=Result.SHUTDOWN_OUT;
return Result.OK;
default :
throw new IllegalStateException();
}
}
 catch (Exception e) {
if (header != null && info instanceof ResponseInfo) {
if (e instanceof BufferOverflowException) {
LOG.warn("Response header too large");
LOG.debug(e);
}
 else LOG.warn(e);
_state=State.COMPLETING;
header.clear();
_persistent=false;
generateResponseLine(RESPONSE_500_INFO,header);
generateHeaders(RESPONSE_500_INFO,header,null,true);
if (buffer != null) BufferUtil.clear(buffer);
if (chunk != null) BufferUtil.clear(chunk);
if (content != null) BufferUtil.clear(content);
return Result.FLUSH;
}
throw e;
}
 finally {
if (pos >= 0) BufferUtil.flipToFlush(header,pos);
}
}
