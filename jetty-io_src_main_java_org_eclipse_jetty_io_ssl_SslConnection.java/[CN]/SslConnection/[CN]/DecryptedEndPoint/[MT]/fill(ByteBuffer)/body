{
  if (DEBUG)   LOG.debug("{} fill enter",SslConnection.this);
  try {
    if (BufferUtil.hasContent(_decryptedInput))     return BufferUtil.flipPutFlip(_decryptedInput,buffer);
    if (_encryptedInput == null)     _encryptedInput=_bufferPool.acquire(_sslEngine.getSession().getPacketBufferSize(),_encryptedDirectBuffers);
 else     BufferUtil.compact(_encryptedInput);
    ByteBuffer app_in;
    if (BufferUtil.space(buffer) > _sslEngine.getSession().getApplicationBufferSize())     app_in=buffer;
 else     if (_decryptedInput == null)     app_in=_decryptedInput=_bufferPool.acquire(_sslEngine.getSession().getApplicationBufferSize(),_decryptedDirectBuffers);
 else     app_in=_decryptedInput;
    while (true) {
      int net_filled=getEndPoint().fill(_encryptedInput);
      if (DEBUG)       LOG.debug("{} filled {} encrypted bytes",SslConnection.this,net_filled);
      if (net_filled > 0)       _underFlown=false;
      int pos=BufferUtil.flipToFill(app_in);
      SSLEngineResult unwrapResult=_sslEngine.unwrap(_encryptedInput,app_in);
      BufferUtil.flipToFlush(app_in,pos);
      if (DEBUG)       LOG.debug("{} unwrap {}",SslConnection.this,unwrapResult);
      Status unwrapResultStatus=unwrapResult.getStatus();
      HandshakeStatus unwrapHandshakeStatus=unwrapResult.getHandshakeStatus();
      HandshakeStatus handshakeStatus=_sslEngine.getHandshakeStatus();
switch (unwrapResultStatus) {
case BUFFER_OVERFLOW:
        throw new IllegalStateException();
case CLOSED:
switch (handshakeStatus) {
case NOT_HANDSHAKING:
        return -1;
case NEED_TASK:
      _sslEngine.getDelegatedTask().run();
    continue;
case NEED_WRAP:
  return -1;
}
throw new IllegalStateException();
default :
if (unwrapHandshakeStatus == HandshakeStatus.FINISHED && !_handshaken) {
_handshaken=true;
if (DEBUG) LOG.debug("{} handshake completed client-side",SslConnection.this);
}
if (_handshaken && handshakeStatus != HandshakeStatus.NOT_HANDSHAKING && !isRenegotiationAllowed()) {
if (DEBUG) LOG.debug("{} renegotiation denied",SslConnection.this);
closeInbound();
return -1;
}
if (unwrapResultStatus == Status.BUFFER_UNDERFLOW) _underFlown=true;
if (unwrapResult.bytesProduced() > 0) {
if (app_in == buffer) return unwrapResult.bytesProduced();
return BufferUtil.flipPutFlip(_decryptedInput,buffer);
}
switch (handshakeStatus) {
case NOT_HANDSHAKING:
if (net_filled < 0) {
closeInbound();
return -1;
}
return 0;
case NEED_TASK:
_sslEngine.getDelegatedTask().run();
continue;
case NEED_WRAP:
if (buffer == __FLUSH_CALLED_FILL) return 0;
_fillRequiresFlushToProgress=true;
flush(__FILL_CALLED_FLUSH);
if (BufferUtil.isEmpty(_encryptedOutput)) {
_fillRequiresFlushToProgress=false;
continue;
}
return 0;
case NEED_UNWRAP:
if (net_filled < 0) {
closeInbound();
return -1;
}
 else if (net_filled > 0) {
continue;
}
return 0;
case FINISHED:
throw new IllegalStateException();
}
}
}
}
 catch (SSLException e) {
getEndPoint().close();
throw new EofException(e);
}
catch (Exception e) {
getEndPoint().close();
throw e;
}
 finally {
if (_flushRequiresFillToProgress) {
_flushRequiresFillToProgress=false;
getExecutor().execute(_runCompletWrite);
}
if (_encryptedInput != null && !_encryptedInput.hasRemaining()) {
_bufferPool.release(_encryptedInput);
_encryptedInput=null;
}
if (_decryptedInput != null && !_decryptedInput.hasRemaining()) {
_bufferPool.release(_decryptedInput);
_decryptedInput=null;
}
if (DEBUG) LOG.debug("{} fill exit",SslConnection.this);
}
}
