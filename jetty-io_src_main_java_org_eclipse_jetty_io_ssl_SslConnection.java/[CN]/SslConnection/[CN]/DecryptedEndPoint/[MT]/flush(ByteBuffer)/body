{
  if (DEBUG)   LOG.debug("{} flush enter {}",SslConnection.this,Arrays.toString(appOuts));
  int consumed=0;
  try {
    if (_cannotAcceptMoreAppDataToFlush) {
      if (_sslEngine.isOutboundDone())       throw new EofException(new ClosedChannelException());
      return false;
    }
    if (_encryptedOutput == null)     _encryptedOutput=_bufferPool.acquire(_sslEngine.getSession().getPacketBufferSize(),_encryptedDirectBuffers);
    while (true) {
      BufferUtil.compact(_encryptedOutput);
      int pos=BufferUtil.flipToFill(_encryptedOutput);
      SSLEngineResult wrapResult=_sslEngine.wrap(appOuts,_encryptedOutput);
      if (DEBUG)       LOG.debug("{} wrap {}",SslConnection.this,wrapResult);
      BufferUtil.flipToFlush(_encryptedOutput,pos);
      if (wrapResult.bytesConsumed() > 0)       consumed+=wrapResult.bytesConsumed();
      boolean allConsumed=true;
      for (      ByteBuffer b : appOuts) {
        if (BufferUtil.isEmpty(b))         BufferUtil.clear(b);
 else         allConsumed=false;
      }
      Status wrapResultStatus=wrapResult.getStatus();
switch (wrapResultStatus) {
case CLOSED:
        if (BufferUtil.hasContent(_encryptedOutput)) {
          _cannotAcceptMoreAppDataToFlush=true;
          getEndPoint().flush(_encryptedOutput);
          getEndPoint().shutdownOutput();
          if (BufferUtil.hasContent(_encryptedOutput))           return false;
        }
 else {
          getEndPoint().shutdownOutput();
        }
      return allConsumed;
case BUFFER_UNDERFLOW:
    throw new IllegalStateException();
default :
  if (DEBUG)   LOG.debug("{} {} {}",this,wrapResultStatus,BufferUtil.toDetailString(_encryptedOutput));
if (wrapResult.getHandshakeStatus() == HandshakeStatus.FINISHED && !_handshaken) {
  _handshaken=true;
  if (DEBUG)   LOG.debug("{} {} handshake completed",SslConnection.this,"server-side");
}
HandshakeStatus handshakeStatus=_sslEngine.getHandshakeStatus();
if (_handshaken && handshakeStatus != HandshakeStatus.NOT_HANDSHAKING && !isRenegotiationAllowed()) {
if (DEBUG) LOG.debug("{} renegotiation denied",SslConnection.this);
shutdownOutput();
return allConsumed;
}
if (BufferUtil.hasContent(_encryptedOutput)) getEndPoint().flush(_encryptedOutput);
switch (handshakeStatus) {
case NOT_HANDSHAKING:
return allConsumed && BufferUtil.isEmpty(_encryptedOutput);
case NEED_TASK:
_sslEngine.getDelegatedTask().run();
continue;
case NEED_WRAP:
continue;
case NEED_UNWRAP:
if (appOuts[0] != __FILL_CALLED_FLUSH && !getFillInterest().isInterested()) {
_flushRequiresFillToProgress=true;
fill(__FLUSH_CALLED_FILL);
if (handshakeStatus == HandshakeStatus.NEED_WRAP) continue;
}
return allConsumed && BufferUtil.isEmpty(_encryptedOutput);
case FINISHED:
throw new IllegalStateException();
}
}
}
}
 catch (Exception e) {
getEndPoint().close();
throw e;
}
 finally {
if (DEBUG) LOG.debug("{} flush exit, consumed {}",SslConnection.this,consumed);
releaseEncryptedOutputBuffer();
}
}
