{
  LOG.debug("{} flush enter {}",SslConnection.this,appOuts);
  try {
    if (_netWriting)     return 0;
    if (_netOut == null)     _netOut=_bufferPool.acquire(_sslEngine.getSession().getPacketBufferSize() * 2,_netDirect);
    while (true) {
      BufferUtil.compact(_netOut);
      int pos=BufferUtil.flipToFill(_netOut);
      _wrapResult=_sslEngine.wrap(appOuts,_netOut);
      LOG.debug("{} wrap {}",SslConnection.this,_wrapResult);
      BufferUtil.flipToFlush(_netOut,pos);
switch (_wrapResult.getStatus()) {
case CLOSED:
        if (BufferUtil.hasContent(_netOut)) {
          _netWriting=true;
          getEndPoint().flush(_netOut);
          if (BufferUtil.hasContent(_netOut))           return 0;
        }
      if (_fillWrap)       return 0;
    throw new EofException();
case BUFFER_UNDERFLOW:
  throw new IllegalStateException();
case BUFFER_OVERFLOW:
if (LOG.isDebugEnabled()) LOG.debug("{} OVERFLOW {}",this,BufferUtil.toDetailString(_netOut));
default :
if (BufferUtil.hasContent(_netOut)) {
getEndPoint().flush(_netOut);
return _wrapResult.bytesConsumed();
}
switch (_sslEngine.getHandshakeStatus()) {
case NOT_HANDSHAKING:
return 0;
case NEED_TASK:
_sslEngine.getDelegatedTask().run();
continue;
case NEED_WRAP:
continue;
case NEED_UNWRAP:
if (!_fillWrap && !_readInterest.isInterested()) {
_flushUnwrap=true;
fill(BufferUtil.EMPTY_BUFFER);
}
return 0;
case FINISHED:
throw new IllegalStateException();
}
}
}
}
 catch (Exception e) {
getEndPoint().close();
throw e;
}
 finally {
LOG.debug("{} flush exit",SslConnection.this);
releaseNetOut();
}
}
