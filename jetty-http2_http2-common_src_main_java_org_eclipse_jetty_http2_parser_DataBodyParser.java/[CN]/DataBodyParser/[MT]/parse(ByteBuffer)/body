{
  boolean loop=false;
  while (buffer.hasRemaining() || loop) {
switch (state) {
case PREPARE:
{
        length=getBodyLength();
        if (isPaddingHigh()) {
          state=State.PADDING_HIGH;
        }
 else         if (isPaddingLow()) {
          state=State.PADDING_LOW;
        }
 else {
          state=State.DATA;
        }
        break;
      }
case PADDING_HIGH:
{
      paddingLength=(buffer.get() & 0xFF) << 8;
      --length;
      if (length < 1 + 256) {
        return notifyConnectionFailure(ErrorCode.PROTOCOL_ERROR,"invalid_data_frame_padding");
      }
      state=State.PADDING_LOW;
      break;
    }
case PADDING_LOW:
{
    paddingLength+=buffer.get() & 0xFF;
    --length;
    length-=paddingLength;
    state=State.DATA;
    loop=length == 0;
    if (length < 0) {
      return notifyConnectionFailure(ErrorCode.PROTOCOL_ERROR,"invalid_data_frame_padding");
    }
    break;
  }
case DATA:
{
  int size=Math.min(buffer.remaining(),length);
  int position=buffer.position();
  int limit=buffer.limit();
  buffer.limit(position + size);
  ByteBuffer slice=buffer.slice();
  buffer.limit(limit);
  buffer.position(position + size);
  length-=size;
  if (length == 0) {
    state=State.PADDING;
    loop=paddingLength == 0;
    if (onData(slice,false)) {
      return Result.ASYNC;
    }
  }
 else {
    if (onData(slice,true)) {
      return Result.ASYNC;
    }
  }
  break;
}
case PADDING:
{
int size=Math.min(buffer.remaining(),paddingLength);
buffer.position(buffer.position() + size);
paddingLength-=size;
if (paddingLength == 0) {
  reset();
  return Result.COMPLETE;
}
break;
}
default :
{
throw new IllegalStateException();
}
}
}
return Result.PENDING;
}
