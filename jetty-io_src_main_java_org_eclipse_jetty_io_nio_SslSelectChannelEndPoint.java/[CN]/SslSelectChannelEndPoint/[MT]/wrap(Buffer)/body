{
  ByteBuffer bbuf=extractOutputBuffer(buffer);
synchronized (bbuf) {
    int consumed=0;
    needOutBuffer();
    _outNIOBuffer.compact();
    ByteBuffer out_buffer=_outNIOBuffer.getByteBuffer();
synchronized (out_buffer) {
      try {
        bbuf.position(buffer.getIndex());
        bbuf.limit(buffer.putIndex());
        out_buffer.position(_outNIOBuffer.putIndex());
        out_buffer.limit(out_buffer.capacity());
        _result=_engine.wrap(bbuf,out_buffer);
        if (_debug)         LOG.debug("{} wrap {}",_session,_result);
        if (!_handshook && _result.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.FINISHED)         _handshook=true;
        _outNIOBuffer.setPutIndex(out_buffer.position());
        consumed=_result.bytesConsumed();
      }
 catch (      SSLException e) {
        LOG.warn(getRemoteAddr() + ":" + getRemotePort()+ " ",e);
        if (getChannel().isOpen())         getChannel().close();
        throw e;
      }
 finally {
        out_buffer.position(0);
        bbuf.position(0);
        bbuf.limit(bbuf.capacity());
        if (consumed > 0) {
          int len=consumed < buffer.length() ? consumed : buffer.length();
          buffer.skip(len);
          consumed-=len;
        }
      }
    }
  }
switch (_result.getStatus()) {
case BUFFER_UNDERFLOW:
    throw new IllegalStateException();
case BUFFER_OVERFLOW:
  LOG.debug("{} wrap {}",_session,_result);
flush();
return 0;
case OK:
return _result.bytesConsumed();
case CLOSED:
_closing=true;
return _result.bytesConsumed() > 0 ? _result.bytesConsumed() : -1;
default :
LOG.warn("{} wrap default {}",_session,_result);
throw new IOException(_result.toString());
}
}
