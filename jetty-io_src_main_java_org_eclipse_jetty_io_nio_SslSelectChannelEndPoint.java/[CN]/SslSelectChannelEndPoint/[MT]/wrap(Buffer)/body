{
  ByteBuffer bbuf=extractOutputBuffer(buffer);
synchronized (bbuf) {
    int consumed=0;
    needOutBuffer();
    try {
      _outNIOBuffer.compact();
      ByteBuffer out_buffer=_outNIOBuffer.getByteBuffer();
synchronized (out_buffer) {
        try {
          bbuf.position(buffer.getIndex());
          bbuf.limit(buffer.putIndex());
          out_buffer.position(_outNIOBuffer.putIndex());
          out_buffer.limit(out_buffer.capacity());
          _result=_engine.wrap(bbuf,out_buffer);
          if (_debug)           LOG.debug("{} wrap {}",_session,_result);
          if (!_handshook && _result.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.FINISHED)           _handshook=true;
          _outNIOBuffer.setPutIndex(out_buffer.position());
          consumed=_result.bytesConsumed();
        }
 catch (        SSLException e) {
          LOG.warn(getRemoteAddr() + ":" + getRemotePort()+ " ",e);
          if (getChannel().isOpen())           getChannel().close();
          throw e;
        }
 finally {
          out_buffer.position(0);
          bbuf.position(0);
          bbuf.limit(bbuf.capacity());
          if (consumed > 0) {
            int len=consumed < buffer.length() ? consumed : buffer.length();
            buffer.skip(len);
            consumed-=len;
          }
        }
      }
    }
  finally {
      releaseOutBuffer();
    }
  }
switch (_result.getStatus()) {
case BUFFER_UNDERFLOW:
    throw new IllegalStateException();
case BUFFER_OVERFLOW:
  LOG.debug("{} wrap {}",_session,_result);
flush();
return 0;
case OK:
return _result.bytesConsumed();
case CLOSED:
System.err.println("wrap CLOSE");
if (super.isOpen()) super.close();
return _result.bytesConsumed() > 0 ? _result.bytesConsumed() : -1;
default :
LOG.warn("{} wrap default {}",_session,_result);
throw new IOException(_result.toString());
}
}
