{
  IStream associatedStream=streams.get(frame.getAssociatedStreamId());
  IStream stream=new StandardStream(frame.getStreamId(),frame.getPriority(),this,associatedStream,promise);
  flowControlStrategy.onNewStream(this,stream);
  stream.updateCloseState(frame.isClose(),local);
  stream.setStreamFrameListener(listener);
  if (stream.isUnidirectional()) {
    stream.updateCloseState(true,!local);
    if (!stream.isClosed())     stream.getAssociatedStream().associate(stream);
  }
  int streamId=stream.getId();
  if (local) {
    while (true) {
      int oldStreamCountValue=localStreamCount.get();
      int maxConcurrentStreams=maxConcurrentLocalStreams;
      if (maxConcurrentStreams > -1 && oldStreamCountValue >= maxConcurrentStreams) {
        String msg=String.format("Max concurrent local streams (%d) exceeded.",maxConcurrentStreams);
        LOG.debug(msg);
        promise.failed(new SPDYException(msg));
        return null;
      }
      if (localStreamCount.compareAndSet(oldStreamCountValue,oldStreamCountValue + 1))       break;
    }
  }
  if (streams.putIfAbsent(streamId,stream) != null) {
    if (local) {
      localStreamCount.decrementAndGet();
      throw new IllegalStateException("Duplicate stream id " + streamId);
    }
    RstInfo rstInfo=new RstInfo(streamId,StreamStatus.PROTOCOL_ERROR);
    LOG.debug("Duplicate stream, {}",rstInfo);
    try {
      rst(rstInfo);
    }
 catch (    InterruptedException|ExecutionException|TimeoutException e) {
      e.printStackTrace();
    }
    return null;
  }
 else {
    LOG.debug("Created {}",stream);
    notifyStreamCreated(stream);
    return stream;
  }
}
