{
  final int windowSize=1536;
  final int length=5 * windowSize;
  final CountDownLatch settingsLatch=new CountDownLatch(1);
  Session session=startClient(startServer(new ServerSessionFrameListener.Adapter(){
    @Override public void onSettings(    Session session,    SettingsInfo settingsInfo){
      settingsLatch.countDown();
    }
    @Override public StreamFrameListener onSyn(    Stream stream,    SynInfo synInfo){
      stream.reply(new ReplyInfo(false));
      stream.data(new BytesDataInfo(new byte[length],true));
      return null;
    }
  }
),null);
  Settings settings=new Settings();
  settings.put(new Settings.Setting(Settings.ID.INITIAL_WINDOW_SIZE,windowSize));
  session.settings(new SettingsInfo(settings));
  Assert.assertTrue(settingsLatch.await(5,TimeUnit.SECONDS));
  final Exchanger<DataInfo> exchanger=new Exchanger<>();
  session.syn(new SynInfo(true),new StreamFrameListener.Adapter(){
    private AtomicInteger dataFrames=new AtomicInteger();
    @Override public void onData(    Stream stream,    DataInfo dataInfo){
      try {
        int dataFrames=this.dataFrames.incrementAndGet();
        if (dataFrames == 1) {
          exchanger.exchange(dataInfo);
        }
 else         if (dataFrames == 2) {
          dataInfo.readInto(ByteBuffer.allocate(dataInfo.length()));
          exchanger.exchange(dataInfo);
        }
 else         if (dataFrames == 3) {
          dataInfo.drainInto(ByteBuffer.allocate(dataInfo.length() / 2));
          exchanger.exchange(dataInfo);
        }
 else         if (dataFrames == 4 || dataFrames == 5) {
          dataInfo.drainInto(ByteBuffer.allocate(dataInfo.length()));
          exchanger.exchange(dataInfo);
        }
 else {
          Assert.fail();
        }
      }
 catch (      InterruptedException x) {
        throw new SPDYException(x);
      }
    }
  }
);
  DataInfo dataInfo=exchanger.exchange(null,5,TimeUnit.SECONDS);
  expectException(TimeoutException.class,new Callable<DataInfo>(){
    @Override public DataInfo call() throws Exception {
      return exchanger.exchange(null,1,TimeUnit.SECONDS);
    }
  }
);
  Assert.assertEquals(windowSize,dataInfo.available());
  Assert.assertEquals(0,dataInfo.consumed());
  dataInfo.drainInto(ByteBuffer.allocate(dataInfo.available()));
  dataInfo=exchanger.exchange(null,5,TimeUnit.SECONDS);
  expectException(TimeoutException.class,new Callable<DataInfo>(){
    @Override public DataInfo call() throws Exception {
      return exchanger.exchange(null,1,TimeUnit.SECONDS);
    }
  }
);
  Assert.assertEquals(0,dataInfo.available());
  Assert.assertEquals(0,dataInfo.consumed());
  dataInfo.consume(dataInfo.length());
  dataInfo=exchanger.exchange(null,5,TimeUnit.SECONDS);
  expectException(TimeoutException.class,new Callable<DataInfo>(){
    @Override public DataInfo call() throws Exception {
      return exchanger.exchange(null,1,TimeUnit.SECONDS);
    }
  }
);
  Assert.assertEquals(dataInfo.length() / 2,dataInfo.consumed());
  dataInfo.drainInto(ByteBuffer.allocate(dataInfo.available()));
  dataInfo=exchanger.exchange(null,5,TimeUnit.SECONDS);
  Assert.assertEquals(dataInfo.length(),dataInfo.consumed());
  dataInfo=exchanger.exchange(null,5,TimeUnit.SECONDS);
  Assert.assertEquals(dataInfo.length(),dataInfo.consumed());
}
