{
  executor.execute(new Runnable(){
    @Override public void run(){
      Scheduler.Task task=null;
      final AtomicBoolean complete=new AtomicBoolean();
      if (timeout > 0) {
        final Thread thread=Thread.currentThread();
        task=scheduler.schedule(new Runnable(){
          @Override public void run(){
            if (complete.compareAndSet(false,true)) {
              promise.failed(new TimeoutException());
              thread.interrupt();
            }
          }
        }
,timeout,TimeUnit.MILLISECONDS);
      }
      try {
        long start=System.nanoTime();
        InetSocketAddress result=new InetSocketAddress(host,port);
        long elapsed=System.nanoTime() - start;
        if (LOG.isDebugEnabled())         LOG.debug("Resolved {} in {} ms",host,TimeUnit.NANOSECONDS.toMillis(elapsed));
        if (complete.compareAndSet(false,true)) {
          if (result.isUnresolved())           promise.failed(new UnresolvedAddressException());
 else           promise.succeeded(result);
        }
      }
 catch (      Throwable x) {
        if (complete.compareAndSet(false,true))         promise.failed(x);
      }
 finally {
        if (task != null)         task.cancel();
        Thread.interrupted();
      }
    }
  }
);
}
