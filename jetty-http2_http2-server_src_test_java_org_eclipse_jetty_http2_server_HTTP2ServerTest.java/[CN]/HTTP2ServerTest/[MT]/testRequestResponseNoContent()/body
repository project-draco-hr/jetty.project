{
  final CountDownLatch latch=new CountDownLatch(3);
  startServer(new HttpServlet(){
    @Override protected void service(    HttpServletRequest req,    HttpServletResponse resp) throws ServletException, IOException {
      latch.countDown();
    }
  }
);
  String host="localhost";
  int port=connector.getLocalPort();
  HttpFields fields=new HttpFields();
  MetaData.Request metaData=new MetaData.Request(HttpScheme.HTTP,HttpMethod.GET.asString(),host + ":" + port,host,port,path,fields);
  HeadersFrame request=new HeadersFrame(1,metaData,null,true);
  Generator.LeaseCallback lease=generator.generate(request,Callback.Adapter.INSTANCE);
  lease.prepend(ByteBuffer.wrap(PrefaceParser.PREFACE_BYTES),false);
  try (Socket client=new Socket(host,port)){
    OutputStream output=client.getOutputStream();
    for (    ByteBuffer buffer : lease.getByteBuffers()) {
      output.write(BufferUtil.toArray(buffer));
    }
    final AtomicReference<HeadersFrame> frameRef=new AtomicReference<>();
    Parser parser=new Parser(byteBufferPool,new Parser.Listener.Adapter(){
      @Override public boolean onSettings(      SettingsFrame frame){
        latch.countDown();
        return false;
      }
      @Override public boolean onHeaders(      HeadersFrame frame){
        frameRef.set(frame);
        latch.countDown();
        return false;
      }
    }
);
    byte[] buffer=new byte[2048];
    InputStream input=client.getInputStream();
    client.setSoTimeout(1000);
    while (true) {
      try {
        int read=input.read(buffer);
        if (read <= 0)         throw new EOFException();
        parser.parse(ByteBuffer.wrap(buffer,0,read));
      }
 catch (      SocketTimeoutException x) {
        break;
      }
    }
    Assert.assertTrue(latch.await(5,TimeUnit.SECONDS));
    HeadersFrame response=frameRef.get();
    Assert.assertNotNull(response);
    MetaData.Response responseMetaData=(MetaData.Response)response.getMetaData();
    Assert.assertEquals(200,responseMetaData.getStatus());
  }
 }
